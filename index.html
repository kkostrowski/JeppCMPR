<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JeppCMPR v2.5.0 - PDF Comparison Tool</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: url('A_monochromatic_background_inspired_by_Jeppesen_en.png') no-repeat center center fixed;
            background-size: cover;
            min-height: 100vh;
            padding: 0;
            margin: 0;
            position: relative;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            text-rendering: optimizeLegibility;
        }

        body::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 150%;
            background: black;
            opacity: 0.8;
            pointer-events: none;
            z-index: -1;
        }

        .container {
            max-width: 100%;
            margin: 0;
            background: rgba(43, 43, 59, 0.5);
            border-radius: 0;
            box-shadow: none;
            overflow: hidden;
            min-height: 100vh;
        }

        .header {
            background: rgba(0, 86, 214, 0.9);
            color: white;
            padding: 20px 30px;
            text-align: center;
            position: relative;
            margin: 0;
            border-radius: 0;
        }

        .header h1 {
            font-size: 1.8em;
            margin-bottom: 5px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
            font-weight: 600;
            letter-spacing: 0.5px;
        }

        .header p {
            font-size: 0.9em;
            opacity: 0.9;
        }

        .version-badge {
            position: absolute;
            top: 10px;
            right: 20px;
            background: rgba(255,255,255,0.2);
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 0.9em;
        }

        .upload-section {
            padding: 40px;
            text-align: center;
            background: transparent;
        }

        .drop-zone {
            border: 3px dashed rgba(0, 86, 214, 0.8);
            border-radius: 15px;
            padding: 60px 40px;
            background: rgba(43, 43, 59, 0.9);
            transition: all 0.3s ease;
            cursor: pointer;
            margin-bottom: 30px;
        }

        .drop-zone:hover, .drop-zone.drag-over {
            background: rgba(60, 60, 79, 0.9);
            border-color: rgba(0, 86, 214, 1);
            transform: scale(1.02);
        }

        .drop-zone-icon {
            font-size: 4em;
            margin-bottom: 20px;
        }

        .drop-zone-text {
            font-size: 1.3em;
            color: rgba(0, 86, 214, 1);
            margin-bottom: 10px;
            font-weight: bold;
        }

        .drop-zone-hint {
            color: #ccc;
            font-size: 0.95em;
        }

        .btn {
            padding: 16px 40px;
            font-size: 1.15em;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .btn-primary {
            background: rgba(0, 86, 214, 0.9);
            color: white;
        }

        .btn-primary:hover {
            background: rgba(0, 68, 179, 0.9);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
        }

        .btn-secondary {
            background: rgba(60, 60, 79, 0.8);
            color: white;
        }

        .btn-secondary:hover {
            background: rgba(60, 60, 79, 1);
        }

        .quality-selector {
            margin: 30px auto;
            padding: 20px;
            background: rgba(0, 86, 214, 0.1);
            border: 2px solid rgba(0, 86, 214, 0.3);
            border-radius: 10px;
            max-width: 600px;
        }

        .quality-selector h3 {
            color: rgba(0, 86, 214, 1);
            margin-bottom: 15px;
            text-align: center;
            font-size: 1.1em;
        }

        .quality-options {
            display: flex;
            justify-content: center;
            gap: 15px;
            flex-wrap: nowrap;
        }

        .quality-option {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 12px 20px;
            background: rgba(43, 43, 59, 0.8);
            border: 2px solid rgba(0, 86, 214, 0.3);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            flex: 1;
            max-width: 200px;
        }

        .quality-option:hover {
            background: rgba(60, 60, 79, 0.9);
            border-color: rgba(0, 86, 214, 0.6);
            transform: translateY(-2px);
        }

        .quality-option input[type="radio"] {
            margin-bottom: 8px;
            width: 20px;
            height: 20px;
            cursor: pointer;
        }

        .quality-option label {
            cursor: pointer;
            font-weight: 600;
            color: white;
            margin-bottom: 5px;
            font-size: 1.1em;
        }

        .quality-option .quality-scale {
            font-size: 0.85em;
            color: #ccc;
        }

        .quality-option.selected {
            background: rgba(0, 86, 214, 0.3);
            border-color: rgba(0, 86, 214, 1);
            box-shadow: 0 0 15px rgba(0, 86, 214, 0.5);
        }

        .file-input {
            display: none;
        }

        .comparison-section {
            display: none;
            padding: 20px 10px;
        }

        .comparison-grid {
            display: flex;
            gap: 0;
            min-height: 600px;
            width: 100%;
        }

        .sidebar {
            background: rgba(43, 43, 59, 0.95);
            padding: 15px;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            max-height: calc(100vh - 140px);
            border-radius: 12px;
            margin: 10px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.4);
            flex-shrink: 0;
        }

        .sidebar-left {
            border-right: none;
            width: 350px;
        }

        .sidebar-right {
            border-left: none;
            width: 150px;
        }

        .main-content {
            flex: 1;
            min-width: 400px;
            position: relative;
        }

        .resizer {
            width: 8px;
            background: rgba(0, 86, 214, 0.3);
            cursor: col-resize;
            flex-shrink: 0;
            position: relative;
            transition: background 0.2s;
        }

        .resizer:hover {
            background: rgba(0, 86, 214, 0.6);
        }

        .resizer::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 3px;
            height: 40px;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 2px;
        }

        .sidebar h3 {
            margin-bottom: 10px;
            color: white;
            font-size: 1.2em;
        }

        .new-comparison-btn {
            width: 100%;
            padding: 12px;
            margin-bottom: 15px;
            background: rgba(0, 86, 214, 0.9);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 3px 10px rgba(0,0,0,0.2);
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .new-comparison-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }

        .manual-pairing {
            display: flex;
            gap: 5px;
            margin-bottom: 10px;
        }

        .mini-dropzone {
            flex: 1;
            border: 2px dashed #999;
            border-radius: 6px;
            padding: 8px 4px;
            text-align: center;
            font-size: 0.75em;
            font-weight: bold;
            background: rgba(60, 60, 79, 0.5);
            cursor: pointer;
            transition: all 0.2s ease;
            min-height: 50px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
        }

        .mini-dropzone.old {
            border-color: #dc3545;
            color: #dc3545;
        }

        .mini-dropzone.new {
            border-color: #28a745;
            color: #28a745;
        }

        .mini-dropzone.drag-over {
            background: rgba(80, 80, 99, 0.6);
            transform: scale(1.05);
        }

        .mini-dropzone.old.drag-over {
            background: #ffe8e8;
        }

        .mini-dropzone.new.drag-over {
            background: #e8ffe8;
        }

        .mini-dropzone.filled {
            background: #e8f4f8;
            border-style: solid;
        }

        .mini-dropzone.old.filled {
            background: #ffe8e8;
            border-color: #dc3545;
        }

        .mini-dropzone.new.filled {
            background: #e8ffe8;
            border-color: #28a745;
        }

        .mini-dropzone-text {
            font-size: 0.85em;
        }

        .mini-dropzone-file {
            font-size: 0.7em;
            margin-top: 2px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            max-width: 100%;
        }

        .mini-dropzone-count {
            font-size: 0.75em;
            margin-top: 3px;
            font-weight: bold;
            color: rgba(0, 86, 214, 0.9);
        }

        .create-pair-btn {
            padding: 6px;
            background: rgba(0, 86, 214, 0.9);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            font-size: 0.8em;
            margin-bottom: 10px;
            transition: all 0.2s ease;
        }

        .create-pair-btn:hover:not(:disabled) {
            background: rgba(0, 68, 179, 0.9);
            transform: translateY(-1px);
        }

        .create-pair-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .sidebar-scroll {
            flex: 1;
            overflow-y: auto;
            margin-bottom: 10px;
        }

        .main-content {
            display: flex;
            flex-direction: column;
            background: white;
        }

        .control-panel {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .control-item {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .control-item label {
            font-weight: bold;
            color: white;
            font-size: 1.0em;
        }

        .control-item input[type="range"] {
            width: 100%;
        }

        .control-item .value-display {
            text-align: center;
            font-size: 0.8em;
            color: #ccc;
        }

        .mode-buttons {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .mode-btn {
            padding: 8px;
            border: 2px solid rgba(0, 86, 214, 0.9);
            background: rgba(60, 60, 79, 0.5);
            color: white;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
            font-size: 0.93em;
            text-align: center;
        }

        .mode-btn.active {
            background: rgba(0, 86, 214, 0.9);
            color: white;
        }

        .view-control {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .view-buttons {
            display: flex;
            gap: 6px;
        }

        .view-btn {
            flex: 1;
            padding: 8px;
            border: 2px solid #999;
            background: rgba(60, 60, 79, 0.5);
            color: white;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
            font-size: 0.93em;
        }

        .view-btn.active-old {
            background: #dc3545;
            border-color: #dc3545;
            color: white;
        }

        .view-btn.active-new {
            background: #28a745;
            border-color: #28a745;
            color: white;
        }

        .auto-btn {
            padding: 8px;
            border: 2px solid #999;
            background: rgba(60, 60, 79, 0.5);
            color: white;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
            font-size: 0.93em;
        }

        .auto-btn.active {
            background: #007bff;
            border-color: #007bff;
            color: white;
        }

        .action-btn {
            padding: 8px;
            background: rgba(0, 86, 214, 0.9);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            font-size: 0.93em;
            transition: all 0.3s ease;
        }

        .action-btn:hover {
            background: rgba(0, 68, 179, 0.9);
        }

        .ocr-btn {
            padding: 8px;
            border: 2px solid #ffc107;
            background: rgba(60, 60, 79, 0.5);
            color: white;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
            font-size: 0.93em;
            text-align: center;
        }

        .ocr-btn.active {
            background: #ffc107;
            color: #000;
        }

        .ocr-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .icao-group {
            margin-bottom: 8px;
        }

        .icao-header {
            padding: 8px 10px;
            background: rgba(0, 86, 214, 0.9);
            color: white;
            font-weight: bold;
            font-size: 1.0em;
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.3s ease;
            user-select: none;
        }

        .icao-header:hover {
            transform: translateX(3px);
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }

        .icao-header.unpaired-old {
            background: linear-gradient(135deg, #dc3545 0%, #c82333 100%);
        }

        .icao-header.unpaired-new {
            background: linear-gradient(135deg, #28a745 0%, #218838 100%);
        }

        .icao-header.no-icao {
            background: linear-gradient(135deg, #ff9800 0%, #f57c00 100%);
        }

        .icao-header .arrow {
            transition: transform 0.3s ease;
        }

        .icao-header.collapsed .arrow {
            transform: rotate(-90deg);
        }

        .icao-files {
            max-height: none;
            overflow: visible;
            opacity: 1;
        }

        .icao-files.hidden {
            max-height: 0;
            opacity: 0;
            overflow: hidden;
            transition: max-height 0.3s ease, opacity 0.3s ease;
        }

        .pair-item-sidebar {
            padding: 8px;
            background: rgba(60, 60, 79, 0.5);
            margin: 3px 0;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
            border-left: 2px solid transparent;
            font-size: 0.93em;
            display: flex;
            align-items: center;
            gap: 6px;
            color: white;
        }

        .pair-item-sidebar .checkbox {
            width: 14px;
            height: 14px;
            border: 2px solid rgba(0, 86, 214, 0.9);
            border-radius: 3px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            background: rgba(60, 60, 79, 0.8);
            transition: all 0.2s ease;
            font-size: 10px;
        }

        .pair-item-sidebar.checked .checkbox {
            background: #28a745;
            border-color: #28a745;
        }

        .pair-item-sidebar.checked .checkbox::after {
            content: '✓';
            color: white;
            font-weight: bold;
        }

        .pair-item-sidebar:hover {
            background: rgba(80, 80, 99, 0.6);
            transform: translateX(2px);
        }

        .pair-item-sidebar.active {
            background: rgba(0, 86, 214, 0.9);
            color: white;
            border-left-color: rgba(0, 68, 179, 0.9);
        }

        .pair-item-sidebar.active-unpaired-old {
            background: #dc3545;
            color: white;
            border-left-color: #c82333;
        }

        .pair-item-sidebar.active-unpaired-new {
            background: #28a745;
            color: white;
            border-left-color: #218838;
        }

        .pair-item-sidebar.active .checkbox,
        .pair-item-sidebar.active-unpaired-old .checkbox,
        .pair-item-sidebar.active-unpaired-new .checkbox {
            border-color: white;
        }

        .pair-item-sidebar .pair-name {
            flex: 1;
            min-width: 0;
            word-wrap: break-word;
            overflow-wrap: break-word;
            line-height: 1.3;
        }

        .pair-item-sidebar .pair-name-main {
            font-weight: bold;
        }

        .pair-item-sidebar .pair-name-pages {
            font-size: 0.9em;
            color: #ccc;
            margin-top: 2px;
        }

        .pair-item-sidebar .ocr-status {
            font-size: 0.9em;
            margin-left: auto;
        }

        .pair-item-sidebar .fuzzy-warning {
            font-size: 1.2em;
            cursor: help;
            position: relative;
        }

        .pair-item-sidebar .fuzzy-warning:hover::after {
            content: attr(data-tooltip);
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #ffc107;
            color: #000;
            padding: 12px 18px;
            border-radius: 8px;
            white-space: normal;
            max-width: 300px;
            font-size: 0.8em;
            font-weight: bold;
            z-index: 99999;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
            text-align: center;
        }

        .pair-item-sidebar .remove-pair-btn {
            background: none;
            color: #dc3545;
            border: none;
            border-radius: 0;
            padding: 2px 5px;
            font-size: 0.9em;
            cursor: pointer;
            transition: all 0.2s ease;
            margin-left: 4px;
        }

        .pair-item-sidebar .remove-pair-btn:hover {
            color: #c82333;
            transform: scale(1.15);
        }

        .unpaired-item-sidebar {
            padding: 6px 8px;
            background: rgba(60, 60, 79, 0.5);
            margin: 2px 0;
            border-radius: 4px;
            cursor: grab;
            transition: all 0.2s ease;
            font-size: 0.85em;
            border-left: 2px solid transparent;
            color: white;
        }

        .unpaired-item-sidebar:hover {
            background: rgba(80, 80, 99, 0.6);
            transform: translateX(2px);
        }

        .unpaired-item-sidebar.dragging {
            opacity: 0.5;
            cursor: grabbing;
        }

        .unpaired-item-sidebar.selected {
            background: rgba(0, 86, 214, 0.9);
            color: white;
            border-left-color: rgba(0, 68, 179, 0.9);
            font-weight: bold;
        }

        .viewer-wrapper {
            padding: 20px;
            background: rgba(43, 43, 59, 0.7);
            display: flex;
            align-items: flex-start;
            justify-content: center;
            min-height: 600px;
            position: relative;
            overflow: auto;
            z-index: 1;
        }

        .viewer-wrapper:fullscreen {
            overflow: hidden;
        }

        .sidebyside-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            width: 100%;
            height: 100%;
        }

        .sidebyside-viewer {
            position: relative;
            background: rgba(60, 60, 79, 0.5);
            border-radius: 8px;
            overflow: auto;
            display: flex;
            align-items: flex-start;
            justify-content: center;
            padding: 10px;
        }

        .canvas-container {
            position: relative;
            display: inline-block;
            background: white;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
            max-width: 100%;
            transition: transform 0.1s ease-out;
            transform-origin: 0 0;
        }

        canvas {
            display: block;
            max-width: 100%;
            height: auto;
        }

        .canvas-label {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 8px 15px;
            border-radius: 5px;
            font-weight: bold;
            font-size: 0.95em;
            z-index: 1000;
            pointer-events: none;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
        }

        .sidebyside-label {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 8px 15px;
            border-radius: 5px;
            font-weight: bold;
            font-size: 0.95em;
            z-index: 1000;
            pointer-events: none;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
        }

        .sidebyside-label.old {
            background: rgba(220, 53, 69, 0.8);
        }

        .sidebyside-label.new {
            background: rgba(40, 167, 69, 0.8);
        }

        .pdf-annotation {
            position: absolute;
            cursor: pointer;
            z-index: 9999;
        }

        .pdf-annotation-icon {
            width: 24px;
            height: 24px;
            background: #ffc107;
            border: 2px solid #ff9800;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: #000;
            font-size: 14px;
        }

        .pdf-annotation-popup {
            position: fixed;
            background: #fff;
            border: 3px solid #ffc107;
            border-radius: 10px;
            padding: 15px;
            max-width: 400px;
            min-width: 200px;
            box-shadow: 0 8px 30px rgba(0,0,0,0.4);
            z-index: 99999;
            display: none;
            font-size: 0.9em;
            line-height: 1.4;
        }

        .pdf-annotation-popup strong {
            display: block;
            margin-bottom: 8px;
            color: #ff9800;
            font-size: 1.1em;
        }

        .reset-zoom-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 86, 214, 0.85);
            color: white;
            border: none;
            border-radius: 8px;
            padding: 12px 18px;
            cursor: pointer;
            font-weight: bold;
            font-size: 0.95em;
            z-index: 1000;
            transition: all 0.3s ease;
            box-shadow: 0 3px 12px rgba(0,0,0,0.3);
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .reset-zoom-btn:hover {
            background: rgba(0, 86, 214, 1);
            transform: scale(1.08);
        }

        .fullscreen-toggle-btn {
            position: absolute;
            top: 55px;
            right: 10px;
            background: rgba(40, 167, 69, 0.85);
            color: white;
            border: none;
            border-radius: 8px;
            padding: 12px 18px;
            cursor: pointer;
            font-weight: bold;
            font-size: 0.95em;
            z-index: 1000;
            transition: all 0.3s ease;
            box-shadow: 0 3px 12px rgba(0,0,0,0.3);
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .fullscreen-toggle-btn:hover {
            background: rgba(40, 167, 69, 1);
            transform: scale(1.08);
        }

        .exit-fullscreen-btn {
            position: absolute;
            top: 55px;
            right: 10px;
            background: rgba(43, 43, 59, 0.85);
            color: white;
            border: none;
            border-radius: 8px;
            padding: 12px 18px;
            cursor: pointer;
            font-weight: bold;
            font-size: 0.95em;
            z-index: 1000;
            transition: all 0.3s ease;
            box-shadow: 0 3px 12px rgba(0,0,0,0.3);
            display: none;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .exit-fullscreen-btn:hover {
            background: rgba(43, 43, 59, 1);
            transform: scale(1.08);
        }

        .viewer-wrapper:fullscreen .exit-fullscreen-btn {
            display: block;
        }

        .viewer-wrapper:fullscreen .fullscreen-toggle-btn {
            display: none;
        }

        .fullscreen-map-name {
            position: absolute;
            top: 10px;
            left: 150px;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 8px 15px;
            border-radius: 5px;
            font-weight: bold;
            font-size: 0.95em;
            z-index: 1000;
            pointer-events: none;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            max-width: 50%;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .viewer-wrapper:fullscreen .fullscreen-map-name {
            display: block !important;
        }

        .fullscreen-shortcuts {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(70, 70, 85, 0.9);
            color: white;
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 0.85em;
            z-index: 1000;
            pointer-events: none;
            box-shadow: 0 3px 15px rgba(0,0,0,0.4);
            line-height: 1.6;
        }

        .fullscreen-shortcuts kbd {
            background: rgba(0, 86, 214, 0.8);
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 0.9em;
            font-weight: bold;
            font-family: monospace;
        }

        .viewer-wrapper:fullscreen .fullscreen-shortcuts {
            display: block !important;
        }

        .ocr-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 999;
            transform-origin: 0 0;
        }

        .loading {
            display: none;
            text-align: center;
            padding: 40px;
        }

        .spinner {
            border: 5px solid #f3f3f3;
            border-top: 5px solid rgba(0, 86, 214, 0.9);
            border-radius: 50%;
            width: 60px;
            height: 60px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .page-nav {
            display: flex;
            gap: 10px;
            align-items: center;
            justify-content: center;
            padding: 10px;
            background: rgba(43, 43, 59, 0.9);
            border-bottom: 1px solid rgba(0, 86, 214, 0.5);
        }

        .page-nav button {
            padding: 8px 16px;
            background: rgba(0, 86, 214, 0.9);
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            font-size: 0.85em;
        }

        .page-nav button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .page-info {
            padding: 8px 16px;
            background: rgba(60, 60, 79, 0.8);
            border-radius: 5px;
            font-weight: bold;
            font-size: 0.85em;
            color: white;
        }

        .jad-generator {
            padding: 12px;
            background: rgba(0, 86, 214, 0.15);
            border: 2px solid rgba(0, 86, 214, 0.4);
            border-radius: 10px;
            font-size: 0.95em;
            color: white;
        }

        .jad-header {
            font-weight: bold;
            color: rgba(0, 86, 214, 1);
            margin-bottom: 10px;
            text-align: center;
            font-size: 1.05em;
        }

        .jad-control {
            margin-bottom: 10px;
        }

        .jad-control label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: white;
            font-size: 0.9em;
        }

        .jad-control select {
            width: 100%;
            padding: 8px;
            background: rgba(60, 60, 79, 0.8);
            color: white;
            border: 2px solid rgba(0, 86, 214, 0.5);
            border-radius: 6px;
            font-size: 0.9em;
            cursor: pointer;
            font-weight: 600;
        }

        .jad-control select:hover {
            border-color: rgba(0, 86, 214, 0.8);
            background: rgba(70, 70, 89, 0.9);
        }

        .jad-label {
            margin-bottom: 8px;
            font-size: 0.85em;
            color: #ccc;
            text-align: center;
        }

        .jad-code-container {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .jad-code {
            flex: 1;
            padding: 10px;
            background: rgba(60, 60, 79, 0.9);
            border: 2px solid rgba(0, 86, 214, 0.6);
        
        /* Manual alignment mode styles */
        .manual-align-point {
            position: absolute;
            width: 12px;
            height: 12px;
            background: red;
            border: 2px solid white;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 10;
        }
        
        .manual-align-label {
            position: absolute;
            background: red;
            color: white;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 12px;
            font-weight: bold;
            transform: translate(-50%, -200%);
            pointer-events: none;
            z-index: 11;
        }
        
        .manual-align-status {
            position: absolute;
            top: 60px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 86, 214, 0.95);
            color: white;
            padding: 12px 24px;
            border-radius: 8px;
            font-weight: bold;
            font-size: 1.1em;
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }
        
        .canvas-container.manual-align-mode {
            cursor: crosshair !important;
        }
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            font-size: 0.85em;
            color: #4fc3f7;
            font-weight: bold;
            word-break: break-all;
            min-height: 40px;
            display: flex;
            align-items: center;
        }

        .jad-copy-btn {
            width: 40px;
            height: 40px;
            padding: 0;
            background: rgba(0, 86, 214, 0.8);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 1.2em;
            transition: all 0.3s ease;
            flex-shrink: 0;
        }

        .jad-copy-btn:hover {
            background: rgba(0, 86, 214, 1);
            transform: scale(1.1);
        }

        .jad-copy-btn:active {
            transform: scale(0.95);
        }

        .ocr-progress {
            font-size: 0.93em;
            color: #ffc107;
            margin-top: 4px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>✈️ JeppCMPR</h1>
            <p>Professional PDF Comparison Tool with Advanced Frame Alignment</p>
            <div class="version-badge">v2.5.0 - Manual Alignment</div>
        </div>

        <div class="upload-section" id="uploadSection">
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 30px; margin-bottom: 20px;">
                <div>
                    <div class="drop-zone" id="dropZoneOld" style="border-color: #dc3545;">
                        <div class="drop-zone-icon">📥</div>
                        <div class="drop-zone-text" style="color: #dc3545;">Przeciągnij pliki OLD tutaj</div>
                        <div class="drop-zone-hint">lub użyj przycisku poniżej</div>
                    </div>
                    <button class="btn btn-primary" onclick="loadOldFolder()" style="width: 100%; margin-top: 15px; background: linear-gradient(135deg, #dc3545 0%, #c82333 100%);">
                        📂 Wybierz pliki OLD
                    </button>
                    <div id="oldFilesCount" style="margin-top: 10px; text-align: center; color: #ccc;">Nie załadowano</div>
                </div>
                
                <div>
                    <div class="drop-zone" id="dropZoneNew" style="border-color: #28a745;">
                        <div class="drop-zone-icon">📥</div>
                        <div class="drop-zone-text" style="color: #28a745;">Przeciągnij pliki NEW tutaj</div>
                        <div class="drop-zone-hint">lub użyj przycisku poniżej</div>
                    </div>
                    <button class="btn btn-primary" onclick="loadNewFolder()" style="width: 100%; margin-top: 15px; background: linear-gradient(135deg, #28a745 0%, #218838 100%);">
                        📂 Wybierz pliki NEW
                    </button>
                    <div id="newFilesCount" style="margin-top: 10px; text-align: center; color: #ccc;">Nie załadowano</div>
                </div>
            </div>

            <div id="compareButtonContainer" style="text-align: center; display: none;">
                <button class="btn btn-primary" onclick="startComparison()" style="padding: 20px 50px; font-size: 1.3em;">
                    🚀 Rozpocznij porównanie
                </button>
            </div>

            <!-- Quality Selector -->
            <div class="quality-selector">
                <h3>⚙️ Jakość renderowania PDF</h3>
                <div class="quality-options">
                    <div class="quality-option" onclick="selectQuality('low')">
                        <input type="radio" name="quality" id="quality-low" value="low">
                        <label for="quality-low">Niska</label>
                        <div class="quality-scale">Scale: 1.5</div>
                        <div class="quality-scale">Szybkie ładowanie</div>
                    </div>
                    <div class="quality-option selected" onclick="selectQuality('standard')">
                        <input type="radio" name="quality" id="quality-standard" value="standard" checked>
                        <label for="quality-standard">Standardowa</label>
                        <div class="quality-scale">Scale: 3.0</div>
                        <div class="quality-scale">Balans jakość/szybkość</div>
                    </div>
                    <div class="quality-option" onclick="selectQuality('high')">
                        <input type="radio" name="quality" id="quality-high" value="high">
                        <label for="quality-high">Wysoka</label>
                        <div class="quality-scale">Scale: 4.5</div>
                        <div class="quality-scale">Najlepsza jakość</div>
                    </div>
                </div>
            </div>

            <input type="file" id="oldFileInput" class="file-input" accept=".pdf" multiple>
            <input type="file" id="newFileInput" class="file-input" accept=".pdf" multiple>
        </div>

        <div class="loading" id="loading">
            <div class="spinner"></div>
            <p id="loadingText">Ładowanie i przetwarzanie plików PDF...</p>
            <div style="width: 80%; max-width: 600px; margin: 20px auto; background: #f0f0f0; border-radius: 10px; overflow: hidden;">
                <div id="progressBar" style="height: 30px; background: rgba(0, 86, 214, 0.9); width: 0%; transition: width 0.3s ease; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold;">
                    0%
                </div>
            </div>
            <p id="progressDetail" style="color: #ccc; font-size: 0.9em;">Przygotowanie...</p>
        </div>

        <div class="comparison-section" id="comparisonSection">
            <div class="comparison-grid">
                <!-- Left Sidebar -->
                <div class="sidebar sidebar-left" id="leftSidebar">
                    <button class="new-comparison-btn" onclick="resetAndUpload()">🔄 Nowe porównanie</button>
                    
                    <!-- Manual Pairing Zone -->
                    <div class="manual-pairing">
                        <div class="mini-dropzone old" id="dropZoneManualOld">
                            <div class="mini-dropzone-text">🎯 OLD</div>
                            <div class="mini-dropzone-file" id="manualOldFile">przeciągnij tutaj</div>
                            <div class="mini-dropzone-count" id="manualOldCount"></div>
                        </div>
                        <div class="mini-dropzone new" id="dropZoneManualNew">
                            <div class="mini-dropzone-text">🎯 NEW</div>
                            <div class="mini-dropzone-file" id="manualNewFile">przeciągnij tutaj</div>
                            <div class="mini-dropzone-count" id="manualNewCount"></div>
                        </div>
                    </div>
                    <button class="create-pair-btn" id="createPairBtn" onclick="createManualPair()" disabled>
                        ➕ Utwórz parę
                    </button>
                    
                    <div class="sidebar-scroll" id="pairListSidebar"></div>
                    
                    <div class="jad-generator">
                        <div class="jad-header">📋 JAD Project Name</div>
                        <div class="jad-control">
                            <label>ASSET:</label>
                            <select id="jadAsset" onchange="updateJADCode()">
                                <option value="SAQ">SAQ</option>
                                <option value="DET" selected>DET</option>
                                <option value="APP">APP</option>
                                <option value="SIDSTAR">SIDSTAR</option>
                                <option value="ENR">ENR</option>
                            </select>
                        </div>
                        <div class="jad-label">Proponowana nazwa projektu:</div>
                        <div class="jad-code-container">
                            <div class="jad-code" id="jadCode">-</div>
                            <button class="jad-copy-btn" onclick="copyJADCode()" title="Kopiuj do schowka">📋</button>
                        </div>
                    </div>
                </div>
                
                <!-- Left Resizer -->
                <div class="resizer" id="leftResizer"></div>
                
                <!-- Main Content -->
                <div class="main-content" id="mainContent">
                    <div class="page-nav" id="pageNav" style="display: none;">
                        <button onclick="prevPage()">⬅️ Poprzednia</button>
                        <div class="page-info" id="pageInfo">Strona 1 z 1</div>
                        <button onclick="nextPage()">Następna ➡️</button>
                    </div>

                    <div class="viewer-wrapper" id="viewerWrapper">
                        <div id="viewer"></div>
                        <div class="canvas-label" id="canvasLabel" style="display: none;"></div>
                        <div class="fullscreen-map-name" id="fullscreenMapName" style="display: none;"></div>
                        <div class="fullscreen-shortcuts" id="fullscreenShortcuts" style="display: none;">
                            <div style="font-weight: bold; margin-bottom: 5px; color: rgba(0, 86, 214, 1);">⌨️ Skróty klawiszowe:</div>
                            <div><kbd>Ctrl</kbd> - Zmień OLD/NEW</div>
                            <div><kbd>←</kbd> <kbd>→</kbd> - Poprzednia/Następna strona</div>
                            <div><kbd>↑</kbd> <kbd>↓</kbd> - Poprzednia/Następna mapa</div>
                            <div><kbd>P</kbd> - Pixel Diff ON/OFF</div>
                        </div>
                        <button class="reset-zoom-btn" id="resetZoomBtn" style="display: none;">🔄 Reset widoku</button>
                        <button class="fullscreen-toggle-btn" id="fullscreenToggleBtn" style="display: none;" onclick="toggleFullscreen()">🖵 Pełny ekran</button>
                        <button class="exit-fullscreen-btn" id="exitFullscreenBtn" onclick="toggleFullscreen()">⚙️ Wróć do opcji</button>
                    </div>
                </div>

                <!-- Right Resizer -->
                <div class="resizer" id="rightResizer"></div>

                <!-- Right Sidebar -->
                <div class="sidebar sidebar-right" id="rightSidebar">
                    <div class="control-panel">
                        <div class="control-item">
                            <label>Obrót:</label>
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 6px;">
                                <button class="action-btn" onclick="rotateMap(-90)">↶</button>
                                <button class="action-btn" onclick="rotateMap(90)">↷</button>
                            </div>
                        </div>

                        <div style="border-top: 2px solid #ddd; margin: 5px 0;"></div>

                        <div class="control-item">
                            <label>Jakość:</label>
                            <select id="qualitySelectRuntime" onchange="changeQualityRuntime()" style="width: 100%; padding: 8px; background: rgba(60, 60, 79, 0.8); color: white; border: 2px solid rgba(0, 86, 214, 0.5); border-radius: 6px; font-size: 0.93em; cursor: pointer;">
                                <option value="low">Niska (1.5x)</option>
                                <option value="standard" selected>Standardowa (3.0x)</option>
                                <option value="high">Wysoka (4.5x)</option>
                            </select>
                        </div>

                        <div style="border-top: 2px solid #ddd; margin: 5px 0;"></div>

                        <div class="control-item">
                            <label>Tryb:</label>
                            <div class="mode-buttons">
                                <div class="mode-btn active" onclick="setMode('toggle')">🔄 Przełączanie</div>
                                <div class="mode-btn" onclick="setMode('overlay')">🎨 Nakładanie</div>
                                <div class="mode-btn" onclick="setMode('manual')">🎯 Ręczne dopasowanie</div>
                            </div>
                        </div>
                        
                        <div class="control-item" id="manualAlignControls" style="display: none;">
                            <button class="action-btn" onclick="resetManualAlignment()" style="width: 100%; background: rgba(255, 193, 7, 0.9);">🔄 Reset do naturalnego</button>
                            <div style="font-size: 0.75em; color: #ccc; margin-top: 5px; line-height: 1.3;">
                                <strong>Instrukcja:</strong> Kliknij 4 punkty na OLD, potem 4 na NEW. Mapy zostaną dopasowane.
                            </div>
                        </div>

                        <div class="control-item">
                            <label>OLD ← → NEW:</label>
                            <input type="range" id="opacityRange" min="0" max="100" value="50" step="5">
                            <div class="value-display" id="opacityValue">50%</div>
                        </div>

                        <div class="control-item">
                            <div class="mode-buttons">
                                <div class="mode-btn" onclick="setMode('sidebyside')">↔️ Obok siebie</div>
                            </div>
                        </div>

                        <div style="border-top: 2px solid #ddd; margin: 5px 0;"></div>

                        <div class="control-item">
                            <label>Widok:</label>
                            <div class="view-control">
                                <button class="auto-btn" id="autoBtn" onclick="toggleAutoMode()">▶️ Auto</button>
                                <div class="view-buttons">
                                    <button class="view-btn" id="oldBtn" onclick="showOldOnly()">OLD</button>
                                    <button class="view-btn" id="newBtn" onclick="showNewOnly()">NEW</button>
                                </div>
                            </div>
                        </div>

                        <div class="control-item">
                            <label>Prędkość:</label>
                            <input type="range" id="speedRange" min="100" max="2000" value="500" step="100">
                            <div class="value-display" id="speedValue">0.5s</div>
                        </div>

                        <div style="border-top: 2px solid #ddd; margin: 5px 0;"></div>

                        <div class="control-item">
                            <label>🔍 Analiza różnic:</label>
                            <div class="mode-buttons">
                                <button class="ocr-btn" id="ocrHybridBtn" onclick="toggleOCRMode('hybrid')" disabled>🟠 Pixel Diff</button>
                            </div>
                        </div>

                        <div class="control-item" id="sensitivityControl" style="display: none;">
                            <label>Czułość wykrywania:</label>
                            <input type="range" id="sensitivityRange" min="0" max="100" value="50" step="5">
                            <div class="value-display" id="sensitivityValue">50%</div>
                            <div style="font-size: 0.75em; color: #ccc; margin-top: 5px; line-height: 1.3;">
                                <strong>0%:</strong> Wykrywa WSZYSTKO (nawet drobne różnice)<br>
                                <strong>50%:</strong> ✅ Zbalansowane (zalecane!)<br>
                                <strong>100%:</strong> Tylko DUŻE różnice<br>
                                <em>minArea = 25px (stałe)</em>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

        let pdfPairs = [];
        let unpairedOld = [];
        let unpairedNew = [];
        let currentPairIndex = 0;
        let currentPageIndex = 0;
        let autoToggleInterval = null;
        let currentMode = 'toggle';
        let viewMode = 'auto';
        let showingOld = true;
        let checkedPairs = new Set();
        let oldFiles = [];
        let newFiles = [];
        let syncState = { zoom: 1, panX: 0, panY: 0 };
        let selectedUnpairedOldIndex = null;
        let selectedUnpairedOldPage = null;
        let selectedUnpairedNewIndex = null;
        let selectedUnpairedNewPage = null;
        
        let ocrMode = null;
        let ocrResults = new Map();
        let currentRotation = 0;
        
        // Render quality setting: 'low' (1.5), 'standard' (3.0), 'high' (4.5)
        let renderQuality = 'standard';

        // FIX #4: Manual pairing with proper file tracking
        let manualPairingOldFiles = [];
        let manualPairingNewFiles = [];
        
        // Alignment offsets
        let alignmentOffsets = new Map();
        
        // PDF annotations cache
        let pdfAnnotations = new Map();
        
        // Manual alignment mode variables
        let manualAlignmentMode = false;
        let manualAlignmentStep = 'map1'; // 'map1' or 'map2'
        let manualAlignmentPoints1 = []; // Points on OLD map
        let manualAlignmentPoints2 = []; // Points on NEW map
        let manualAlignmentTransform = null; // Calculated transformation matrix
        let manualAlignmentOriginalMode = null; // Original mode before manual alignment
        
        // ===== QUALITY FUNCTIONS =====
        
        function getRenderScale() {
            const qualityMap = {
                'low': 1.5,
                'standard': 3.0,
                'high': 4.5
            };
            return qualityMap[renderQuality] || 3.0;
        }
        
        function selectQuality(quality) {
            renderQuality = quality;
            
            // Update radio buttons
            document.querySelectorAll('.quality-option').forEach(opt => {
                opt.classList.remove('selected');
            });
            document.querySelector(`.quality-option input[value="${quality}"]`).closest('.quality-option').classList.add('selected');
            document.getElementById(`quality-${quality}`).checked = true;
            
            console.log(`Quality selected: ${quality} (scale: ${getRenderScale()})`);
        }
        
        async function changeQualityRuntime() {
            const select = document.getElementById('qualitySelectRuntime');
            const newQuality = select.value;
            
            if (newQuality === renderQuality) return;
            
            renderQuality = newQuality;
            console.log(`Quality changed to: ${renderQuality} (scale: ${getRenderScale()})`);
            
            // Recalculate alignment for all pairs with new scale
            console.log('⚙️ Recalculating alignment for all pairs with new render scale...');
            for (let i = 0; i < pdfPairs.length; i++) {
                await calculateFrameAlignment(i);
            }
            
            // Przeładuj aktualną parę z nową jakością
            if (pdfPairs.length > 0 && currentPairIndex < pdfPairs.length) {
                console.log(`Reloading pair ${currentPairIndex} with new quality...`);
                await renderCurrentPage();
            }
        }

        // ===== JAD PROJECT NAME GENERATOR =====
        
        // CELL mapping based on ICAO prefix (first 2 letters)
        const CELL_MAPPING = {
            // G16
            'EP': 'G16', 'EY': 'G16', 'EV': 'G16', 'EE': 'G16', 'LK': 'G16', 'LZ': 'G16', 'LH': 'G16',
            'UK': 'G16', 'UM': 'G16', 'LB': 'G16', 'BK': 'G16', 'LY': 'G16', 'LA': 'G16', 'LR': 'G16',
            'LD': 'G16', 'LJ': 'G16', 'LQ': 'G16', 'LW': 'G16', 'LU': 'G16',
            
            // G2
            'LV': 'G2', 'LT': 'G2', 'LL': 'G2', 'LG': 'G2', 'LC': 'G2', 'OA': 'G2', 'OB': 'G2', 'OE': 'G2',
            'OI': 'G2', 'OJ': 'G2', 'OK': 'G2', 'OL': 'G2', 'OM': 'G2', 'OO': 'G2', 'OP': 'G2', 'OR': 'G2',
            'OS': 'G2', 'OT': 'G2', 'OY': 'G2', 'UA': 'G2', 'UB': 'G2', 'UC': 'G2', 'UD': 'G2', 'UT': 'G2',
            'UZ': 'G2', 'UG': 'G2',
            
            // G7 (Y + others)
            'AG': 'G7', 'AN': 'G7', 'AY': 'G7', 'NC': 'G7', 'NF': 'G7', 'NG': 'G7', 'NI': 'G7', 'NL': 'G7',
            'NS': 'G7', 'NT': 'G7', 'NV': 'G7', 'NW': 'G7', 'NZ': 'G7', 'PC': 'G7', 'PK': 'G7', 'PL': 'G7',
            'PT': 'G7', 'WA': 'G7', 'WB': 'G7', 'WI': 'G7', 'WQ': 'G7', 'WR': 'G7', 'WS': 'G7',
            
            // G17
            'BG': 'G17', 'BI': 'G17', 'EB': 'G17', 'EG': 'G17', 'EH': 'G17', 'EI': 'G17', 'EK': 'G17',
            'EL': 'G17', 'EN': 'G17', 'ES': 'G17', 'EF': 'G17',
            
            // PAC
            'RJ': 'PAC', 'RK': 'PAC', 'RO': 'PAC', 'RP': 'PAC', 'VL': 'PAC', 'VD': 'PAC', 'VT': 'PAC',
            'VV': 'PAC', 'VY': 'PAC',
            
            // INTL1
            'SA': 'INTL1', 'SB': 'INTL1', 'SC': 'INTL1', 'SD': 'INTL1', 'SE': 'INTL1', 'SF': 'INTL1',
            'SG': 'INTL1', 'SH': 'INTL1', 'SI': 'INTL1', 'SJ': 'INTL1', 'SK': 'INTL1', 'SL': 'INTL1',
            'SM': 'INTL1', 'SN': 'INTL1', 'SO': 'INTL1', 'SP': 'INTL1', 'SS': 'INTL1', 'SU': 'INTL1',
            'SV': 'INTL1', 'SW': 'INTL1', 'SY': 'INTL1', 'TA': 'INTL1', 'TB': 'INTL1', 'TD': 'INTL1',
            'TF': 'INTL1', 'TG': 'INTL1', 'TI': 'INTL1', 'TJ': 'INTL1', 'TK': 'INTL1', 'TL': 'INTL1',
            'TN': 'INTL1', 'TQ': 'INTL1', 'TR': 'INTL1', 'TT': 'INTL1', 'TU': 'INTL1', 'TV': 'INTL1',
            'TX': 'INTL1', 'MB': 'INTL1', 'MD': 'INTL1', 'MG': 'INTL1', 'MH': 'INTL1', 'MK': 'INTL1',
            'MM': 'INTL1', 'MN': 'INTL1', 'MP': 'INTL1', 'MR': 'INTL1', 'MS': 'INTL1', 'MT': 'INTL1',
            'MU': 'INTL1', 'MW': 'INTL1', 'MY': 'INTL1', 'MZ': 'INTL1'
        };
        
        // AIRAC cycles - end dates for each cycle
        const AIRAC_CYCLES = [
            // 2025
            { cycle: '2512', endDate: new Date('2025-11-07') },
            { cycle: '2513', endDate: new Date('2025-12-05') },
            // 2026
            { cycle: '2601', endDate: new Date('2026-01-22') },
            { cycle: '2602', endDate: new Date('2026-02-19') },
            { cycle: '2603', endDate: new Date('2026-03-19') },
            { cycle: '2604', endDate: new Date('2026-04-16') },
            { cycle: '2605', endDate: new Date('2026-05-14') },
            { cycle: '2606', endDate: new Date('2026-06-11') },
            { cycle: '2607', endDate: new Date('2026-07-09') },
            { cycle: '2608', endDate: new Date('2026-08-06') },
            { cycle: '2609', endDate: new Date('2026-09-03') },
            { cycle: '2610', endDate: new Date('2026-10-01') },
            { cycle: '2611', endDate: new Date('2026-10-29') },
            { cycle: '2612', endDate: new Date('2026-11-26') },
            { cycle: '2613', endDate: new Date('2026-12-24') },
            // 2027
            { cycle: '2701', endDate: new Date('2027-01-21') },
            { cycle: '2702', endDate: new Date('2027-02-18') },
            { cycle: '2703', endDate: new Date('2027-03-18') },
            { cycle: '2704', endDate: new Date('2027-04-15') },
            { cycle: '2705', endDate: new Date('2027-05-13') },
            { cycle: '2706', endDate: new Date('2027-06-10') },
            { cycle: '2707', endDate: new Date('2027-07-08') },
            { cycle: '2708', endDate: new Date('2027-08-05') },
            { cycle: '2709', endDate: new Date('2027-09-02') },
            { cycle: '2710', endDate: new Date('2027-09-30') },
            { cycle: '2711', endDate: new Date('2027-10-28') },
            { cycle: '2712', endDate: new Date('2027-11-25') },
            { cycle: '2713', endDate: new Date('2027-12-23') },
            // 2028
            { cycle: '2801', endDate: new Date('2028-01-20') },
            { cycle: '2802', endDate: new Date('2028-02-17') },
            { cycle: '2803', endDate: new Date('2028-03-16') },
            { cycle: '2804', endDate: new Date('2028-04-13') },
            { cycle: '2805', endDate: new Date('2028-05-11') },
            { cycle: '2806', endDate: new Date('2028-06-08') },
            { cycle: '2807', endDate: new Date('2028-07-06') },
            { cycle: '2808', endDate: new Date('2028-08-03') },
            { cycle: '2809', endDate: new Date('2028-08-31') },
            { cycle: '2810', endDate: new Date('2028-09-28') },
            { cycle: '2811', endDate: new Date('2028-10-26') },
            { cycle: '2812', endDate: new Date('2028-11-23') },
            { cycle: '2813', endDate: new Date('2028-12-21') }
        ];
        
        function getCELL(icao) {
            if (!icao || icao.length < 2) return 'CELL';
            
            const prefix = icao.substring(0, 2).toUpperCase();
            
            // Check first letter for G11 (C*) and G7 (Y*)
            const firstLetter = icao.charAt(0).toUpperCase();
            if (firstLetter === 'C') return 'G11';
            if (firstLetter === 'Y') return 'G7';
            
            // Check 2-letter prefix
            return CELL_MAPPING[prefix] || 'CELL';
        }
        
        function getOFFICE(cell) {
            // G16, G17, G2, G11, INTL1, PAC, G7 → G
            if (['G16', 'G17', 'G2', 'G11', 'INTL1', 'PAC', 'G7'].includes(cell)) {
                return 'G';
            }
            // K → K (for USA codes starting with K)
            if (cell === 'K') {
                return 'K';
            }
            // Default → D
            return 'D';
        }
        
        function getCYCLE() {
            const today = new Date();
            today.setHours(0, 0, 0, 0); // Normalize to start of day
            
            // Find current cycle - the one where today <= endDate
            for (let i = 0; i < AIRAC_CYCLES.length; i++) {
                const cycle = AIRAC_CYCLES[i];
                if (today <= cycle.endDate) {
                    return cycle.cycle;
                }
            }
            
            // If no cycle found (date beyond our data), return last cycle
            return AIRAC_CYCLES[AIRAC_CYCLES.length - 1].cycle;
        }
        
        function getENT(asset, mapName) {
            const name = (mapName || '').toUpperCase();
            
            switch(asset) {
                case 'DET':
                    return 'RWY';
                    
                case 'APP':
                    // Litera + 2 cyfry
                    let letter = 'R'; // domyślnie R
                    
                    // Określ literę na podstawie typu podejścia
                    if (name.includes('RNP') || name.includes('RNAV')) {
                        letter = 'R';
                    } else if (name.includes('VOR')) {
                        letter = 'S';
                    } else if (name.includes('NDB')) {
                        letter = 'N';
                    } else if (name.includes('TACAN')) {
                        letter = 'T';
                    } else if (name.includes('ILS') || name.includes('LOC')) {
                        letter = 'I';
                    }
                    
                    // Wyciągnij 2 cyfry po słowie "RWY"
                    const rwyMatch = name.match(/RWY\s*(\d{2})/);
                    const digits = rwyMatch ? rwyMatch[1] : '00';
                    
                    return `${letter}${digits}`;
                    
                case 'SIDSTAR':
                    // STAR lub SID na podstawie nazwy
                    if (name.includes('STAR')) {
                        return 'STAR';
                    } else if (name.includes('SID')) {
                        return 'SID';
                    }
                    return 'SIDSTAR'; // fallback
                    
                case 'ENR':
                    return 'BNDR';
                    
                case 'SAQ':
                    return 'SAQ';
                    
                default:
                    return 'ENT';
            }
        }
        
        function generateJADCode() {
            // Get current ICAO and map name from active pair
            let icao = 'ICAO';
            let mapName = '';
            
            if (pdfPairs.length > 0 && currentPairIndex >= 0 && currentPairIndex < pdfPairs.length) {
                const pair = pdfPairs[currentPairIndex];
                if (pair) {
                    if (pair.icao) {
                        icao = pair.icao;
                    }
                    if (pair.name) {
                        mapName = pair.name;
                    }
                }
            }
            
            // Get selected ASSET
            const assetSelect = document.getElementById('jadAsset');
            const asset = assetSelect ? assetSelect.value : 'DET';
            
            // Calculate components
            const cell = getCELL(icao);
            const office = getOFFICE(cell);
            const cycle = getCYCLE();
            const ent = getENT(asset, mapName);
            
            // Format: OFFICE-CELL-CYCLE-ICAO-ASSET-ENT-CHG-
            const code = `${office}-${cell}-${cycle}-${icao}-${asset}-${ent}-CHG-`;
            
            return code;
        }
        
        function updateJADCode() {
            const codeEl = document.getElementById('jadCode');
            if (codeEl) {
                const code = generateJADCode();
                codeEl.textContent = code;
            }
        }
        
        function copyJADCode() {
            const code = generateJADCode();
            
            // Copy to clipboard
            navigator.clipboard.writeText(code).then(() => {
                // Visual feedback
                const btn = document.querySelector('.jad-copy-btn');
                const originalText = btn.textContent;
                btn.textContent = '✓';
                btn.style.background = 'rgba(40, 167, 69, 0.8)';
                
                setTimeout(() => {
                    btn.textContent = originalText;
                    btn.style.background = 'rgba(0, 86, 214, 0.8)';
                }, 1000);
                
                console.log('JAD code copied to clipboard:', code);
            }).catch(err => {
                console.error('Failed to copy:', err);
                alert('Nie udało się skopiować kodu');
            });
        }

        const dropZoneOld = document.getElementById('dropZoneOld');
        const dropZoneNew = document.getElementById('dropZoneNew');
        const oldFileInput = document.getElementById('oldFileInput');
        const newFileInput = document.getElementById('newFileInput');

        dropZoneOld.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZoneOld.classList.add('drag-over');
        });

        dropZoneOld.addEventListener('dragleave', () => {
            dropZoneOld.classList.remove('drag-over');
        });

        dropZoneOld.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZoneOld.classList.remove('drag-over');
            const files = Array.from(e.dataTransfer.files).filter(f => f.name.endsWith('.pdf'));
            if (files.length > 0) {
                oldFiles = files;
                updateFileInfo();
            }
        });

        dropZoneNew.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZoneNew.classList.add('drag-over');
        });

        dropZoneNew.addEventListener('dragleave', () => {
            dropZoneNew.classList.remove('drag-over');
        });

        dropZoneNew.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZoneNew.classList.remove('drag-over');
            const files = Array.from(e.dataTransfer.files).filter(f => f.name.endsWith('.pdf'));
            if (files.length > 0) {
                newFiles = files;
                updateFileInfo();
            }
        });

        oldFileInput.addEventListener('change', (e) => {
            oldFiles = Array.from(e.target.files).filter(f => f.name.endsWith('.pdf'));
            updateFileInfo();
        });

        newFileInput.addEventListener('change', (e) => {
            newFiles = Array.from(e.target.files).filter(f => f.name.endsWith('.pdf'));
            updateFileInfo();
        });

        // FIX #4: Manual pairing dropzones with FILE SUPPORT (not just drag from sidebar)
        const dropZoneManualOld = document.getElementById('dropZoneManualOld');
        const dropZoneManualNew = document.getElementById('dropZoneManualNew');

        dropZoneManualOld.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZoneManualOld.classList.add('drag-over');
        });

        dropZoneManualOld.addEventListener('dragleave', () => {
            dropZoneManualOld.classList.remove('drag-over');
        });

        dropZoneManualOld.addEventListener('drop', async (e) => {
            e.preventDefault();
            dropZoneManualOld.classList.remove('drag-over');
            
            // Check if it's from sidebar or external files
            const data = e.dataTransfer.getData('text/plain');
            if (data.startsWith('unpaired-old-')) {
                const index = parseInt(data.replace('unpaired-old-', ''));
                manualPairingOldFiles = [unpairedOld[index]];
            } else {
                // External files dropped
                const files = Array.from(e.dataTransfer.files).filter(f => f.name.endsWith('.pdf'));
                if (files.length > 0) {
                    // Load PDFs
                    const loadedFiles = [];
                    for (let file of files) {
                        try {
                            const arrayBuffer = await file.arrayBuffer();
                            const doc = await pdfjsLib.getDocument({data: arrayBuffer}).promise;
                            loadedFiles.push({
                                name: file.name,
                                file: file,
                                doc: doc,
                                totalPages: doc.numPages
                            });
                        } catch (error) {
                            console.error(`Error loading ${file.name}:`, error);
                        }
                    }
                    manualPairingOldFiles = loadedFiles;
                }
            }
            updateManualPairingUI();
        });

        dropZoneManualNew.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZoneManualNew.classList.add('drag-over');
        });

        dropZoneManualNew.addEventListener('dragleave', () => {
            dropZoneManualNew.classList.remove('drag-over');
        });

        dropZoneManualNew.addEventListener('drop', async (e) => {
            e.preventDefault();
            dropZoneManualNew.classList.remove('drag-over');
            
            const data = e.dataTransfer.getData('text/plain');
            if (data.startsWith('unpaired-new-')) {
                const index = parseInt(data.replace('unpaired-new-', ''));
                manualPairingNewFiles = [unpairedNew[index]];
            } else {
                // External files dropped
                const files = Array.from(e.dataTransfer.files).filter(f => f.name.endsWith('.pdf'));
                if (files.length > 0) {
                    const loadedFiles = [];
                    for (let file of files) {
                        try {
                            const arrayBuffer = await file.arrayBuffer();
                            const doc = await pdfjsLib.getDocument({data: arrayBuffer}).promise;
                            loadedFiles.push({
                                name: file.name,
                                file: file,
                                doc: doc,
                                totalPages: doc.numPages
                            });
                        } catch (error) {
                            console.error(`Error loading ${file.name}:`, error);
                        }
                    }
                    manualPairingNewFiles = loadedFiles;
                }
            }
            updateManualPairingUI();
        });

        // FIX #4: Show file count and enable button properly
        function updateManualPairingUI() {
            const oldFileEl = document.getElementById('manualOldFile');
            const newFileEl = document.getElementById('manualNewFile');
            const oldCountEl = document.getElementById('manualOldCount');
            const newCountEl = document.getElementById('manualNewCount');
            const createBtn = document.getElementById('createPairBtn');
            const oldZone = document.getElementById('dropZoneManualOld');
            const newZone = document.getElementById('dropZoneManualNew');

            if (manualPairingOldFiles.length > 0) {
                if (manualPairingOldFiles.length === 1) {
                    oldFileEl.textContent = manualPairingOldFiles[0].name.substring(0, 20) + '...';
                } else {
                    oldFileEl.textContent = 'Wiele plików';
                }
                oldCountEl.textContent = `${manualPairingOldFiles.length} plik(ów)`;
                oldZone.classList.add('filled');
            } else {
                oldFileEl.textContent = 'przeciągnij tutaj';
                oldCountEl.textContent = '';
                oldZone.classList.remove('filled');
            }

            if (manualPairingNewFiles.length > 0) {
                if (manualPairingNewFiles.length === 1) {
                    newFileEl.textContent = manualPairingNewFiles[0].name.substring(0, 20) + '...';
                } else {
                    newFileEl.textContent = 'Wiele plików';
                }
                newCountEl.textContent = `${manualPairingNewFiles.length} plik(ów)`;
                newZone.classList.add('filled');
            } else {
                newFileEl.textContent = 'przeciągnij tutaj';
                newCountEl.textContent = '';
                newZone.classList.remove('filled');
            }

            // Enable button when BOTH have files
            createBtn.disabled = !(manualPairingOldFiles.length > 0 && manualPairingNewFiles.length > 0);
        }

        async function createManualPair() {
            if (manualPairingOldFiles.length === 0 || manualPairingNewFiles.length === 0) return;

            // Create pairs from the files
            const minLength = Math.min(manualPairingOldFiles.length, manualPairingNewFiles.length);
            
            for (let i = 0; i < minLength; i++) {
                const oldItem = manualPairingOldFiles[i];
                const newItem = manualPairingNewFiles[i];
                
                const icao = extractICAO(oldItem.name) || extractICAO(newItem.name) || '';

                const newPair = {
                    name: `${oldItem.name} + ${newItem.name}`,
                    icao: icao,
                    oldFile: oldItem.file,
                    newFile: newItem.file,
                    oldDoc: oldItem.doc,
                    newDoc: newItem.doc,
                    totalPages: Math.max(oldItem.totalPages, newItem.totalPages),
                    isPaired: true,
                    isManual: true
                };

                pdfPairs.push(newPair);

                // Remove from unpaired lists if they were there
                const oldIndex = unpairedOld.findIndex(u => u.name === oldItem.name);
                if (oldIndex > -1) unpairedOld.splice(oldIndex, 1);

                const newIndex = unpairedNew.findIndex(u => u.name === newItem.name);
                if (newIndex > -1) unpairedNew.splice(newIndex, 1);

                const pairIndex = pdfPairs.length - 1;
                await calculateFrameAlignment(pairIndex);
            }

            manualPairingOldFiles = [];
            manualPairingNewFiles = [];
            updateManualPairingUI();
            renderPairList();
            updateStats();

            await loadPair(pdfPairs.length - 1);
        }

        function extractICAO(filename) {
            // Szukaj pierwszego 4-literowego słowa składającego się TYLKO z wielkich liter
            const match = filename.match(/\b([A-Z]{4})\b/);
            return match ? match[1] : 'NO ICAO';
        }

        function removePair(index) {
            if (index < 0 || index >= pdfPairs.length) return;

            const pair = pdfPairs[index];

            if (pair.isManual) {
                unpairedOld.push({
                    name: pair.oldFile.name,
                    file: pair.oldFile,
                    doc: pair.oldDoc,
                    totalPages: pair.oldDoc.numPages
                });

                unpairedNew.push({
                    name: pair.newFile.name,
                    file: pair.newFile,
                    doc: pair.newDoc,
                    totalPages: pair.newDoc.numPages
                });

                unpairedOld.sort((a, b) => a.name.localeCompare(b.name));
                unpairedNew.sort((a, b) => a.name.localeCompare(b.name));
            }

            pdfPairs.splice(index, 1);
            checkedPairs.delete(index);

            const newChecked = new Set();
            checkedPairs.forEach(i => {
                if (i > index) newChecked.add(i - 1);
                else if (i < index) newChecked.add(i);
            });
            checkedPairs = newChecked;

            if (pdfPairs.length > 0) {
                const newIndex = Math.min(index, pdfPairs.length - 1);
                loadPair(newIndex);
            }

            renderPairList();
            updateStats();
        }

        function updateFileInfo() {
            const oldCount = document.getElementById('oldFilesCount');
            const newCount = document.getElementById('newFilesCount');
            const compareContainer = document.getElementById('compareButtonContainer');

            if (oldFiles.length > 0) {
                oldCount.textContent = `✅ Załadowano ${oldFiles.length} plików`;
                oldCount.style.color = '#28a745';
                oldCount.style.fontWeight = 'bold';
            } else {
                oldCount.textContent = '❌ Nie załadowano';
                oldCount.style.color = '#999';
            }

            if (newFiles.length > 0) {
                newCount.textContent = `✅ Załadowano ${newFiles.length} plików`;
                newCount.style.color = '#28a745';
                newCount.style.fontWeight = 'bold';
            } else {
                newCount.textContent = '❌ Nie załadowano';
                newCount.style.color = '#999';
            }

            compareContainer.style.display = (oldFiles.length > 0 && newFiles.length > 0) ? 'block' : 'none';
        }

        function startComparison() {
            // Synchronizuj quality z upload section do runtime control
            const runtimeSelect = document.getElementById('qualitySelectRuntime');
            if (runtimeSelect) {
                runtimeSelect.value = renderQuality;
            }
            
            processFiles(oldFiles, newFiles);
        }

        function loadOldFolder() {
            oldFileInput.click();
        }

        function loadNewFolder() {
            newFileInput.click();
        }

        function levenshteinDistance(str1, str2) {
            const len1 = str1.length;
            const len2 = str2.length;
            const matrix = [];

            for (let i = 0; i <= len1; i++) {
                matrix[i] = [i];
            }

            for (let j = 0; j <= len2; j++) {
                matrix[0][j] = j;
            }

            for (let i = 1; i <= len1; i++) {
                for (let j = 1; j <= len2; j++) {
                    if (str1.charAt(i - 1) === str2.charAt(j - 1)) {
                        matrix[i][j] = matrix[i - 1][j - 1];
                    } else {
                        matrix[i][j] = Math.min(
                            matrix[i - 1][j - 1] + 1,
                            matrix[i][j - 1] + 1,
                            matrix[i - 1][j] + 1
                        );
                    }
                }
            }

            return matrix[len1][len2];
        }

        function fuzzyMatch(oldFiles, newFiles) {
            const pairs = [];
            const unmatchedOld = [...oldFiles];
            const unmatchedNew = [...newFiles];

            for (let i = unmatchedOld.length - 1; i >= 0; i--) {
                for (let j = unmatchedNew.length - 1; j >= 0; j--) {
                    if (unmatchedOld[i].name === unmatchedNew[j].name) {
                        pairs.push({
                            oldFile: unmatchedOld[i],
                            newFile: unmatchedNew[j],
                            distance: 0
                        });
                        unmatchedOld.splice(i, 1);
                        unmatchedNew.splice(j, 1);
                        break;
                    }
                }
            }

            for (const oldFile of unmatchedOld) {
                let bestMatch = null;
                let bestDistance = Infinity;

                for (const newFile of unmatchedNew) {
                    const distance = levenshteinDistance(oldFile.name, newFile.name);
                    const maxLen = Math.max(oldFile.name.length, newFile.name.length);
                    const similarity = 1 - (distance / maxLen);

                    if (similarity >= 0.7 && distance < bestDistance) {
                        bestMatch = newFile;
                        bestDistance = distance;
                    }
                }

                if (bestMatch) {
                    pairs.push({
                        oldFile: oldFile,
                        newFile: bestMatch,
                        distance: bestDistance
                    });

                    const idx = unmatchedNew.indexOf(bestMatch);
                    if (idx > -1) unmatchedNew.splice(idx, 1);
                }
            }

            const finalOld = unmatchedOld.filter(f => {
                return !pairs.some(p => p.oldFile === f);
            });

            const finalNew = unmatchedNew.filter(f => {
                return !pairs.some(p => p.newFile === f);
            });

            return { pairs, unpairedOld: finalOld, unpairedNew: finalNew };
        }

        async function processFiles(oldFilesList, newFilesList) {
            document.getElementById('uploadSection').style.display = 'none';
            document.getElementById('loading').style.display = 'block';

            const updateProgress = (percent, text) => {
                const bar = document.getElementById('progressBar');
                const detail = document.getElementById('progressDetail');
                bar.style.width = percent + '%';
                bar.textContent = Math.round(percent) + '%';
                detail.textContent = text;
            };

            updateProgress(0, 'Ładowanie plików...');
            await new Promise(resolve => setTimeout(resolve, 100));

            // WSZYSTKIE pliki są akceptowane - bez filtrowania
            const filteredOldFiles = oldFilesList;
            const filteredNewFiles = newFilesList;

            updateProgress(10, 'Inteligentne dopasowywanie par (Fuzzy Matching)...');

            const { pairs: matchedPairs, unpairedOld: unmatchedOld, unpairedNew: unmatchedNew } = 
                fuzzyMatch(filteredOldFiles, filteredNewFiles);

            updateProgress(15, 'Ładowanie plików PDF...');

            const totalFiles = (matchedPairs.length * 2) + unmatchedOld.length + unmatchedNew.length;
            let loadedFiles = 0;

            const pairs = [];
            for (let match of matchedPairs) {
                try {
                    const oldArrayBuffer = await match.oldFile.arrayBuffer();
                    const oldDoc = await pdfjsLib.getDocument({data: oldArrayBuffer}).promise;
                    loadedFiles++;
                    updateProgress(15 + (loadedFiles / totalFiles * 50), `Ładowanie par...`);
                    
                    const newArrayBuffer = await match.newFile.arrayBuffer();
                    const newDoc = await pdfjsLib.getDocument({data: newArrayBuffer}).promise;
                    loadedFiles++;
                    updateProgress(15 + (loadedFiles / totalFiles * 50), `Ładowanie par...`);
                    
                    const icao = extractICAO(match.oldFile.name) || extractICAO(match.newFile.name) || '';

                    pairs.push({
                        name: match.oldFile.name,
                        icao: icao,
                        oldFile: match.oldFile,
                        newFile: match.newFile,
                        oldDoc: oldDoc,
                        newDoc: newDoc,
                        totalPages: Math.max(oldDoc.numPages, newDoc.numPages),
                        isPaired: true,
                        fuzzyDistance: match.distance
                    });
                } catch (error) {
                    console.error(`Error loading pair:`, error);
                }
            }

            pairs.sort((a, b) => {
                if (a.icao !== b.icao) return a.icao.localeCompare(b.icao);
                return a.name.localeCompare(b.name);
            });

            const unpairedOldItems = [];
            for (let file of unmatchedOld) {
                try {
                    const arrayBuffer = await file.arrayBuffer();
                    const doc = await pdfjsLib.getDocument({data: arrayBuffer}).promise;
                    unpairedOldItems.push({
                        name: file.name,
                        file: file,
                        doc: doc,
                        totalPages: doc.numPages
                    });
                    loadedFiles++;
                    updateProgress(15 + (loadedFiles / totalFiles * 50), `Ładowanie OLD...`);
                } catch (error) {
                    console.error(`Error loading ${file.name}:`, error);
                }
            }

            const unpairedNewItems = [];
            for (let file of unmatchedNew) {
                try {
                    const arrayBuffer = await file.arrayBuffer();
                    const doc = await pdfjsLib.getDocument({data: arrayBuffer}).promise;
                    unpairedNewItems.push({
                        name: file.name,
                        file: file,
                        doc: doc,
                        totalPages: doc.numPages
                    });
                    loadedFiles++;
                    updateProgress(15 + (loadedFiles / totalFiles * 50), `Ładowanie NEW...`);
                } catch (error) {
                    console.error(`Error loading ${file.name}:`, error);
                }
            }

            pdfPairs = pairs;
            unpairedOld = unpairedOldItems;
            unpairedNew = unpairedNewItems;

            // FIX #2: MAXIMUM FRAME ALIGNMENT (sub-pixel precision)
            updateProgress(65, 'MAKSYMALNE dopasowanie ramek (sub-pixel precision)...');
            for (let i = 0; i < pdfPairs.length; i++) {
                await calculateFrameAlignment(i);
                updateProgress(65 + (i / pdfPairs.length * 10), `Wyrównywanie ramek ${i + 1}/${pdfPairs.length}...`);
            }

            updateProgress(100, 'Gotowe!');
            await new Promise(resolve => setTimeout(resolve, 500));

            document.getElementById('loading').style.display = 'none';
            document.getElementById('comparisonSection').style.display = 'block';

            renderPairList();
            updateStats();
            
            if (pdfPairs.length > 0) {
                document.getElementById('ocrHybridBtn').disabled = false;
                
                await loadPair(0);
                
                setTimeout(() => {
                    toggleAutoMode();
                }, 500);
            }
        }

        // FIX #2: MAXIMUM FRAME ALIGNMENT with JeppALLIGN v3.18 logic
        async function calculateFrameAlignment(pairIndex) {
            const pair = pdfPairs[pairIndex];
            if (!pair) return;

            try {
                const detectionScale = 2.0;                // Scale for frame detection
                const renderScale = getRenderScale();      // Use current render scale

                const oldCanvas = document.createElement('canvas');
                const oldPage = await pair.oldDoc.getPage(1);
                const oldViewport = oldPage.getViewport({scale: detectionScale});
                oldCanvas.width = oldViewport.width;
                oldCanvas.height = oldViewport.height;
                const oldCtx = oldCanvas.getContext('2d');
                await oldPage.render({canvasContext: oldCtx, viewport: oldViewport}).promise;

                const newCanvas = document.createElement('canvas');
                const newPage = await pair.newDoc.getPage(1);
                const newViewport = newPage.getViewport({scale: detectionScale});
                newCanvas.width = newViewport.width;
                newCanvas.height = newViewport.height;
                const newCtx = newCanvas.getContext('2d');
                await newPage.render({canvasContext: newCtx, viewport: newViewport}).promise;

                const oldFrame = detectFrameMaximum(oldCtx, oldCanvas.width, oldCanvas.height);
                const newFrame = detectFrameMaximum(newCtx, newCanvas.width, newCanvas.height);

                // JeppALLIGN v3.18: Calculate transformations for drawImage()
                const ratio = renderScale / detectionScale;
                
                // Convert frame coordinates to render scale
                const oldF = {
                    x: oldFrame.x * ratio,
                    y: oldFrame.y * ratio,
                    w: oldFrame.width * ratio,
                    h: oldFrame.height * ratio
                };
                
                const newF = {
                    x: newFrame.x * ratio,
                    y: newFrame.y * ratio,
                    w: newFrame.width * ratio,
                    h: newFrame.height * ratio
                };
                
                // Calculate scale so OLD frame has size of NEW frame
                const scaleX = newF.w / oldF.w;
                const scaleY = newF.h / oldF.h;
                
                // Calculate offset so OLD frame is positioned at NEW frame location
                // After scaling, OLD frame will be at (oldF.x * scaleX, oldF.y * scaleY)
                // We want it at (newF.x, newF.y)
                const offsetX = newF.x - oldF.x * scaleX;
                const offsetY = newF.y - oldF.y * scaleY;
                
                alignmentOffsets.set(pairIndex, {
                    offsetX: offsetX,
                    offsetY: offsetY,
                    scaleX: scaleX,
                    scaleY: scaleY,
                    oldFrame: oldF,
                    newFrame: newF,
                    renderScale: renderScale  // Store the scale this alignment was calculated for
                });
                
                console.log('╔═══════════════════════════════════════╗');
                console.log('║  JeppALLIGN v3.18 - Alignment Result  ║');
                console.log('╚═══════════════════════════════════════╝');
                console.log(`Render scale: ${renderScale.toFixed(1)}`);
                console.log(`OLD frame: (${oldF.x.toFixed(2)}, ${oldF.y.toFixed(2)}) ${oldF.w.toFixed(2)}x${oldF.h.toFixed(2)}`);
                console.log(`NEW frame: (${newF.x.toFixed(2)}, ${newF.y.toFixed(2)}) ${newF.w.toFixed(2)}x${newF.h.toFixed(2)}`);
                console.log(`Scale: X=${scaleX.toFixed(4)}, Y=${scaleY.toFixed(4)}`);
                console.log(`Offset: X=${offsetX.toFixed(2)}, Y=${offsetY.toFixed(2)}`);
                console.log('Verification:');
                console.log(`  OLD left after: ${(oldF.x * scaleX + offsetX).toFixed(2)} → ${newF.x.toFixed(2)}`);
                console.log(`  OLD top after: ${(oldF.y * scaleY + offsetY).toFixed(2)} → ${newF.y.toFixed(2)}`);
                console.log('═══════════════════════════════════════');

            } catch (error) {
                console.error(`Frame alignment error for pair ${pairIndex}:`, error);
                alignmentOffsets.set(pairIndex, {
                    offsetX: 0,
                    offsetY: 0,
                    scaleX: 1,
                    scaleY: 1
                });
            }
        }

        // ============================================
        // JEPPALIGN v3.18 - ADVANCED FRAME DETECTION
        // ============================================
        
        // Frame detection parameters - optimized for SOLID frames
        let frameDetectionEdgeThreshold = 12;
        let frameDetectionGapTolerance = 5;
        let frameDetectionLineThreshold = 0.20;
        
        // Helper functions for advanced frame detection
        function extractLineColor(data, width, height, line, isHorizontal) {
            const colors = [];
            const samples = 50;
            
            if (isHorizontal) {
                const y = Math.round(line.y);
                const step = Math.max(1, Math.floor((line.x2 - line.x1) / samples));
                for (let x = line.x1; x <= line.x2; x += step) {
                    const idx = (y * width + Math.round(x)) * 4;
                    if (idx >= 0 && idx < data.length - 3) {
                        colors.push({
                            r: data[idx],
                            g: data[idx + 1],
                            b: data[idx + 2]
                        });
                    }
                }
            } else {
                const x = Math.round(line.x);
                const step = Math.max(1, Math.floor((line.y2 - line.y1) / samples));
                for (let y = line.y1; y <= line.y2; y += step) {
                    const idx = (Math.round(y) * width + x) * 4;
                    if (idx >= 0 && idx < data.length - 3) {
                        colors.push({
                            r: data[idx],
                            g: data[idx + 1],
                            b: data[idx + 2]
                        });
                    }
                }
            }
            
            if (colors.length === 0) return { r: 0, g: 0, b: 0 };
            
            const avgR = colors.reduce((sum, c) => sum + c.r, 0) / colors.length;
            const avgG = colors.reduce((sum, c) => sum + c.g, 0) / colors.length;
            const avgB = colors.reduce((sum, c) => sum + c.b, 0) / colors.length;
            
            return { r: avgR, g: avgG, b: avgB };
        }
        
        function colorDistance(c1, c2) {
            const dr = c1.r - c2.r;
            const dg = c1.g - c2.g;
            const db = c1.b - c2.b;
            return Math.sqrt(dr*dr + dg*dg + db*db);
        }
        
        function colorHarmony(color) {
            const mean = (color.r + color.g + color.b) / 3;
            const variance = ((color.r - mean)**2 + (color.g - mean)**2 + (color.b - mean)**2) / 3;
            return Math.sqrt(variance);
        }
        
        function colorsHaveCompatibleHue(colors) {
            const harmonies = colors.map(c => colorHarmony(c));
            const avgHarmony = harmonies.reduce((a, b) => a + b, 0) / harmonies.length;
            
            for (const h of harmonies) {
                const diff = Math.abs(h - avgHarmony);
                if (diff > 40) {
                    return false;
                }
            }
            return true;
        }
        
        function gaussianBlur(data, width, height) {
            const blurred = new Uint8ClampedArray(data.length);
            const kernel = [1, 2, 1, 2, 4, 2, 1, 2, 1];
            const kernelSum = 16;
            
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    for (let c = 0; c < 3; c++) {
                        let sum = 0;
                        let ki = 0;
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                const i = ((y + dy) * width + (x + dx)) * 4 + c;
                                sum += data[i] * kernel[ki++];
                            }
                        }
                        blurred[(y * width + x) * 4 + c] = sum / kernelSum;
                    }
                    blurred[(y * width + x) * 4 + 3] = 255;
                }
            }
            return blurred;
        }
        
        function sharpenImage(data, width, height) {
            const sharpened = new Uint8ClampedArray(data.length);
            const kernel = [0, -1, 0, -1, 5, -1, 0, -1, 0];
            
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    for (let c = 0; c < 3; c++) {
                        let sum = 0;
                        let ki = 0;
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                const i = ((y + dy) * width + (x + dx)) * 4 + c;
                                sum += data[i] * kernel[ki++];
                            }
                        }
                        sharpened[(y * width + x) * 4 + c] = Math.max(0, Math.min(255, sum));
                    }
                    sharpened[(y * width + x) * 4 + 3] = 255;
                }
            }
            return sharpened;
        }
        
        function detectThinLines(data, width, height, threshold = 20) {
            const edges = new Float32Array(width * height);
            const strength = new Float32Array(width * height);
            
            for (let y = 2; y < height - 2; y++) {
                for (let x = 2; x < width - 2; x++) {
                    const idx = y * width + x;
                    
                    const i = idx * 4;
                    const centerBrightness = (data[i] + data[i+1] + data[i+2]) / 3;
                    
                    let surroundSum = 0;
                    let surroundCount = 0;
                    
                    for (let dy = -2; dy <= 2; dy++) {
                        for (let dx = -2; dx <= 2; dx++) {
                            if (dx === 0 && dy === 0) continue;
                            const si = ((y + dy) * width + (x + dx)) * 4;
                            surroundSum += (data[si] + data[si+1] + data[si+2]) / 3;
                            surroundCount++;
                        }
                    }
                    
                    const surroundAvg = surroundSum / surroundCount;
                    const contrast = surroundAvg - centerBrightness;
                    
                    if (contrast > threshold) {
                        edges[idx] = 1;
                        strength[idx] = contrast;
                    }
                }
            }
            
            return { edges, strength };
        }
        
        // FIX #2: MAXIMUM frame detection with JeppALLIGN v3.18 logic
        function detectFrameMaximum(ctx, width, height) {
            const imageData = ctx.getImageData(0, 0, width, height);
            const data = imageData.data;
            
            // Check if we need sharpening
            let processedData = data;
            let totalContrast = 0;
            const samples = 100;
            for (let i = 0; i < samples; i++) {
                const x = Math.floor(Math.random() * (width - 4)) + 2;
                const y = Math.floor(Math.random() * (height - 4)) + 2;
                const idx = (y * width + x) * 4;
                
                const center = (data[idx] + data[idx+1] + data[idx+2]) / 3;
                let surroundSum = 0;
                for (let dy = -1; dy <= 1; dy++) {
                    for (let dx = -1; dx <= 1; dx++) {
                        if (dx === 0 && dy === 0) continue;
                        const si = ((y + dy) * width + (x + dx)) * 4;
                        surroundSum += (data[si] + data[si+1] + data[si+2]) / 3;
                    }
                }
                const surroundAvg = surroundSum / 8;
                totalContrast += Math.abs(center - surroundAvg);
            }
            const avgContrast = totalContrast / samples;
            
            if (avgContrast < 15) {
                console.log('Low contrast detected, applying sharpening...');
                processedData = sharpenImage(data, width, height);
            }
            
            // Gaussian blur for noise reduction
            const blurred = gaussianBlur(processedData, width, height);
            
            // Sobel edge detection
            const sobelEdges = new Float32Array(width * height);
            const sobelStrength = new Float32Array(width * height);
            
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    const idx = y * width + x;
                    
                    const p = [];
                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dx = -1; dx <= 1; dx++) {
                            const i = ((y + dy) * width + (x + dx)) * 4;
                            p.push((blurred[i] + blurred[i+1] + blurred[i+2]) / 3);
                        }
                    }
                    
                    const gx = -p[0] - 2*p[3] - p[6] + p[2] + 2*p[5] + p[8];
                    const gy = -p[0] - 2*p[1] - p[2] + p[6] + 2*p[7] + p[8];
                    
                    const magnitude = Math.sqrt(gx * gx + gy * gy);
                    sobelStrength[idx] = magnitude;
                    
                    if (magnitude > frameDetectionEdgeThreshold) {
                        sobelEdges[idx] = 1;
                    }
                }
            }
            
            // Contrast-based detection for thin lines
            const contrastResult = detectThinLines(processedData, width, height, 15);
            const contrastEdges = contrastResult.edges;
            const contrastStrength = contrastResult.strength;
            
            // Combine both detections
            const combinedEdges = new Float32Array(width * height);
            const combinedStrength = new Float32Array(width * height);
            
            for (let i = 0; i < width * height; i++) {
                if (sobelEdges[i] === 1 || contrastEdges[i] === 1) {
                    combinedEdges[i] = 1;
                    combinedStrength[i] = Math.max(sobelStrength[i], contrastStrength[i]);
                }
            }
            
            console.log('✅ Edge detection: Sobel + Contrast-based');
            
            const edges = combinedEdges;
            const edgeStrength = combinedStrength;
            
            // Detect lines using robust algorithm from JeppALLIGN
            const horizontalLines = findRobustLines(edges, edgeStrength, width, height, true);
            const verticalLines = findRobustLines(edges, edgeStrength, width, height, false);
            
            console.log(`Detected ${horizontalLines.length} H-lines, ${verticalLines.length} V-lines`);
            
            if (horizontalLines.length < 2 || verticalLines.length < 2) {
                console.log('❌ Not enough lines, using content bbox');
                return detectContentBBox(ctx, width, height);
            }
            
            // Group close lines
            const groupedHLines = groupCloseLines(horizontalLines, true, height);
            const groupedVLines = groupCloseLines(verticalLines, false, width);
            
            console.log(`After grouping: ${groupedHLines.length} H-groups, ${groupedVLines.length} V-groups`);
            
            // Try advanced corner-based frame detection
            const bestFrame = findBestChartFrame(groupedHLines, groupedVLines, width, height, data, edges);
            
            if (!bestFrame) {
                console.log('❌ No proper frame found, using content bbox');
                return detectContentBBox(ctx, width, height);
            }
            
            console.log(`✅ Frame detected: (${Math.round(bestFrame.x)}, ${Math.round(bestFrame.y)}) ${Math.round(bestFrame.width)}x${Math.round(bestFrame.height)}`);
            
            return {
                x: bestFrame.x,
                y: bestFrame.y,
                width: bestFrame.width,
                height: bestFrame.height
            };
        }
        
        // Helper functions for advanced line detection (from JeppALLIGN v3.18)
        function mergeNearSegments(segments, maxGap) {
            if (segments.length === 0) return [];
            
            segments.sort((a, b) => a.start - b.start);
            const merged = [];
            let current = { ...segments[0], solidLength: segments[0].end - segments[0].start + 1 };
            
            for (let i = 1; i < segments.length; i++) {
                const seg = segments[i];
                const gap = seg.start - current.end;
                
                if (gap <= maxGap) {
                    current.end = seg.end;
                    current.totalStrength += seg.totalStrength;
                    current.count += seg.count;
                    current.solidLength += seg.end - seg.start + 1;
                } else {
                    merged.push(current);
                    current = { ...seg, solidLength: seg.end - seg.start + 1 };
                }
            }
            merged.push(current);
            
            return merged;
        }
        
        function findRobustLines(edges, strength, width, height, isHorizontal) {
            const lines = [];
            const size = isHorizontal ? height : width;
            const perpSize = isHorizontal ? width : height;
            
            for (let pos = 0; pos < size; pos++) {
                let lineSegments = [];
                let currentSegment = null;
                
                for (let perp = 0; perp < perpSize; perp++) {
                    const idx = isHorizontal ? (pos * width + perp) : (perp * width + pos);
                    
                    if (edges[idx] === 1) {
                        if (!currentSegment) {
                            currentSegment = {
                                start: perp,
                                end: perp,
                                totalStrength: strength[idx],
                                count: 1
                            };
                        } else {
                            currentSegment.end = perp;
                            currentSegment.totalStrength += strength[idx];
                            currentSegment.count++;
                        }
                    } else {
                        if (currentSegment) {
                            const length = currentSegment.end - currentSegment.start + 1;
                            if (length > frameDetectionGapTolerance) {
                                lineSegments.push(currentSegment);
                            }
                            currentSegment = null;
                        }
                    }
                }
                
                if (currentSegment) {
                    const length = currentSegment.end - currentSegment.start + 1;
                    if (length > frameDetectionGapTolerance) {
                        lineSegments.push(currentSegment);
                    }
                }
                
                const merged = mergeNearSegments(lineSegments, frameDetectionGapTolerance);
                
                for (const seg of merged) {
                    const length = seg.end - seg.start + 1;
                    const avgStrength = seg.totalStrength / seg.count;
                    
                    if (length >= perpSize * frameDetectionLineThreshold) {
                        const coverage = length / perpSize;
                        const continuity = seg.solidLength / length;
                        const score = coverage * Math.pow(continuity, 3) * (avgStrength / 50);
                        
                        const line = isHorizontal ? 
                            { y: pos, x1: seg.start, x2: seg.end, length, continuity, avgStrength, score, solidLength: seg.solidLength } :
                            { x: pos, y1: seg.start, y2: seg.end, length, continuity, avgStrength, score, solidLength: seg.solidLength };
                        
                        lines.push(line);
                    }
                }
            }
            
            return lines;
        }
        
        function groupCloseLines(lines, isHorizontal, dimension) {
            if (lines.length === 0) return [];
            
            lines.sort((a, b) => {
                const posA = isHorizontal ? a.y : a.x;
                const posB = isHorizontal ? b.y : b.x;
                return posA - posB;
            });
            
            const groups = [];
            const groupThreshold = Math.max(3, dimension * 0.005);
            
            let currentGroup = [lines[0]];
            
            for (let i = 1; i < lines.length; i++) {
                const prevPos = isHorizontal ? currentGroup[currentGroup.length - 1].y : currentGroup[currentGroup.length - 1].x;
                const currPos = isHorizontal ? lines[i].y : lines[i].x;
                
                if (currPos - prevPos <= groupThreshold) {
                    currentGroup.push(lines[i]);
                } else {
                    const best = currentGroup.reduce((a, b) => a.score > b.score ? a : b);
                    groups.push(best);
                    currentGroup = [lines[i]];
                }
            }
            
            if (currentGroup.length > 0) {
                const best = currentGroup.reduce((a, b) => a.score > b.score ? a : b);
                groups.push(best);
            }
            
            return groups;
        }
        
        // Corner detection with gap tolerance (from JeppALLIGN v3.18)
        function detectCorners(hLines, vLines, cornerTolerance = 10) {
            const corners = [];
            const maxGap = 3; // Edge Consistency Filter - 3px gap tolerance
            
            for (const hLine of hLines) {
                for (const vLine of vLines) {
                    const vIntersectsH = vLine.x >= hLine.x1 - cornerTolerance && 
                                         vLine.x <= hLine.x2 + cornerTolerance;
                    
                    const hIntersectsV = hLine.y >= vLine.y1 - cornerTolerance && 
                                         hLine.y <= vLine.y2 + cornerTolerance;
                    
                    if (vIntersectsH && hIntersectsV) {
                        const gapHLeft = Math.max(0, hLine.x1 - vLine.x);
                        const gapHRight = Math.max(0, vLine.x - hLine.x2);
                        const gapH = Math.min(gapHLeft, gapHRight);
                        
                        const gapVTop = Math.max(0, vLine.y1 - hLine.y);
                        const gapVBottom = Math.max(0, hLine.y - vLine.y2);
                        const gapV = Math.min(gapVTop, gapVBottom);
                        
                        const maxGapAtCorner = Math.max(gapH, gapV);
                        
                        if (maxGapAtCorner > maxGap) {
                            continue;
                        }
                        
                        const gapPenalty = Math.max(0, 1 - (maxGapAtCorner / maxGap));
                        const continuityScore = (hLine.continuity + vLine.continuity) / 2;
                        const strengthScore = Math.min(1, (hLine.avgStrength + vLine.avgStrength) / 100);
                        
                        const cornerQuality = gapPenalty * continuityScore * strengthScore;
                        
                        corners.push({
                            x: vLine.x,
                            y: hLine.y,
                            hLine: hLine,
                            vLine: vLine,
                            strength: (hLine.avgStrength + vLine.avgStrength) / 2,
                            hContinuity: hLine.continuity,
                            vContinuity: vLine.continuity,
                            avgContinuity: (hLine.continuity + vLine.continuity) / 2,
                            gap: maxGapAtCorner,
                            gapH: gapH,
                            gapV: gapV,
                            quality: cornerQuality
                        });
                    }
                }
            }
            
            return corners;
        }
        
        // Calculate line thickness dynamically
        function calculateLineThickness(hLine, vLine, edges, width, height) {
            let hThickness = 0;
            let vThickness = 0;
            
            const checkX = Math.floor((hLine.x1 + hLine.x2) / 2);
            const checkY = hLine.y;
            
            for (let dy = -5; dy <= 5; dy++) {
                const idx = (checkY + dy) * width + checkX;
                if (edges[idx] === 1) {
                    hThickness++;
                }
            }
            
            const checkY2 = Math.floor((vLine.y1 + vLine.y2) / 2);
            const checkX2 = vLine.x;
            
            for (let dx = -5; dx <= 5; dx++) {
                const idx = checkY2 * width + (checkX2 + dx);
                if (edges[idx] === 1) {
                    vThickness++;
                }
            }
            
            return (hThickness + vThickness) / 2;
        }
        
        // Find frame from 4 corners (from JeppALLIGN v3.18)
        function findFrameFromCorners(corners, width, height, imageData, edges) {
            if (corners.length < 4) {
                console.log(`⚠️ Not enough corners detected: ${corners.length}`);
                return null;
            }
            
            console.log(`🎯 Detected ${corners.length} corners`);
            
            const midX = width / 2;
            const midY = height / 2;
            const edgeMargin = Math.max(10, Math.min(width, height) * 0.02);
            
            console.log(`Edge margin: ${Math.round(edgeMargin)}px (corners within this distance from edge are rejected)`);
            
            // Extract colors for lines
            corners.forEach(corner => {
                corner.hLine.color = corner.hLine.color || extractLineColor(imageData, width, height, corner.hLine, true);
                corner.vLine.color = corner.vLine.color || extractLineColor(imageData, width, height, corner.vLine, false);
            });
            
            // Find candidates in each quadrant
            const topLeftCandidates = corners
                .filter(c => c.x < midX && c.y < midY)
                .filter(c => c.x > edgeMargin && c.y > edgeMargin)
                .sort((a, b) => {
                    const aHasSmallGap = a.gap <= 3;
                    const bHasSmallGap = b.gap <= 3;
                    const aDist = aHasSmallGap ? (a.x + a.y) : Math.max(a.x, a.y);
                    const bDist = bHasSmallGap ? (b.x + b.y) : Math.max(b.x, b.y);
                    const aQualityBonus = a.quality * 5;
                    const bQualityBonus = b.quality * 5;
                    const aGapBonus = (a.gap <= 3) ? 30 : 0;
                    const bGapBonus = (b.gap <= 3) ? 30 : 0;
                    return (aDist - aQualityBonus - aGapBonus) - (bDist - bQualityBonus - bGapBonus);
                });
            
            const topRightCandidates = corners
                .filter(c => c.x > midX && c.y < midY)
                .filter(c => c.x < width - edgeMargin && c.y > edgeMargin)
                .sort((a, b) => {
                    const aHasSmallGap = a.gap <= 3;
                    const bHasSmallGap = b.gap <= 3;
                    const aDist = aHasSmallGap ? ((width - a.x) + a.y) : Math.max(width - a.x, a.y);
                    const bDist = bHasSmallGap ? ((width - b.x) + b.y) : Math.max(width - b.x, b.y);
                    const aQualityBonus = a.quality * 5;
                    const bQualityBonus = b.quality * 5;
                    const aGapBonus = (a.gap <= 3) ? 30 : 0;
                    const bGapBonus = (b.gap <= 3) ? 30 : 0;
                    return (aDist - aQualityBonus - aGapBonus) - (bDist - bQualityBonus - bGapBonus);
                });
            
            const bottomLeftCandidates = corners
                .filter(c => c.x < midX && c.y > midY)
                .filter(c => c.x > edgeMargin && c.y < height - edgeMargin)
                .sort((a, b) => {
                    const aHasSmallGap = a.gap <= 3;
                    const bHasSmallGap = b.gap <= 3;
                    const aDist = aHasSmallGap ? (a.x + (height - a.y)) : Math.max(a.x, height - a.y);
                    const bDist = bHasSmallGap ? (b.x + (height - b.y)) : Math.max(b.x, height - b.y);
                    const aQualityBonus = a.quality * 5;
                    const bQualityBonus = b.quality * 5;
                    const aGapBonus = (a.gap <= 3) ? 30 : 0;
                    const bGapBonus = (b.gap <= 3) ? 30 : 0;
                    return (aDist - aQualityBonus - aGapBonus) - (bDist - bQualityBonus - bGapBonus);
                });
            
            const bottomRightCandidates = corners
                .filter(c => c.x > midX && c.y > midY)
                .filter(c => c.x < width - edgeMargin && c.y < height - edgeMargin)
                .sort((a, b) => {
                    const aHasSmallGap = a.gap <= 3;
                    const bHasSmallGap = b.gap <= 3;
                    const aDist = aHasSmallGap ? ((width - a.x) + (height - a.y)) : Math.max(width - a.x, height - a.y);
                    const bDist = bHasSmallGap ? ((width - b.x) + (height - b.y)) : Math.max(width - b.x, height - b.y);
                    const aQualityBonus = a.quality * 5;
                    const bQualityBonus = b.quality * 5;
                    const aGapBonus = (a.gap <= 3) ? 30 : 0;
                    const bGapBonus = (b.gap <= 3) ? 30 : 0;
                    return (aDist - aQualityBonus - aGapBonus) - (bDist - bQualityBonus - bGapBonus);
                });
            
            console.log(`Quadrant corners: TL=${topLeftCandidates.length}, TR=${topRightCandidates.length}, BL=${bottomLeftCandidates.length}, BR=${bottomRightCandidates.length}`);
            
            if (topLeftCandidates.length === 0 || topRightCandidates.length === 0 || 
                bottomLeftCandidates.length === 0 || bottomRightCandidates.length === 0) {
                console.log('❌ Not enough corners in all quadrants');
                return null;
            }
            
            // Filter dominated corners - keep only outermost
            const filteredTopLeft = topLeftCandidates.length > 0 ? [topLeftCandidates[0]] : [];
            const filteredTopRight = topRightCandidates.length > 0 ? [topRightCandidates[0]] : [];
            const filteredBottomLeft = bottomLeftCandidates.length > 0 ? [bottomLeftCandidates[0]] : [];
            const filteredBottomRight = bottomRightCandidates.length > 0 ? [bottomRightCandidates[0]] : [];
            
            console.log(`🔥 After filtering: TL=${filteredTopLeft.length}, TR=${filteredTopRight.length}, BL=${filteredBottomLeft.length}, BR=${filteredBottomRight.length}`);
            
            let bestFrame = null;
            let bestScore = 0;
            
            const maxCandidates = 3;
            
            for (let tl = 0; tl < Math.min(maxCandidates, filteredTopLeft.length); tl++) {
                for (let tr = 0; tr < Math.min(maxCandidates, filteredTopRight.length); tr++) {
                    for (let bl = 0; bl < Math.min(maxCandidates, filteredBottomLeft.length); bl++) {
                        for (let br = 0; br < Math.min(maxCandidates, filteredBottomRight.length); br++) {
                            const cornerTL = filteredTopLeft[tl];
                            const cornerTR = filteredTopRight[tr];
                            const cornerBL = filteredBottomLeft[bl];
                            const cornerBR = filteredBottomRight[br];
                            
                            const x = cornerTL.x;
                            const y = cornerTL.y;
                            const w = cornerTR.x - cornerTL.x;
                            const h = cornerBL.y - cornerTL.y;
                            
                            if (w < 100 || h < 100 || w > width * 0.95 || h > height * 0.95) {
                                continue;
                            }
                            
                            // Check rectangularity
                            const topRightX = Math.abs(cornerTR.x - (x + w));
                            const topRightY = Math.abs(cornerTR.y - y);
                            const bottomLeftX = Math.abs(cornerBL.x - x);
                            const bottomLeftY = Math.abs(cornerBL.y - (y + h));
                            const bottomRightX = Math.abs(cornerBR.x - (x + w));
                            const bottomRightY = Math.abs(cornerBR.y - (y + h));
                            
                            const maxDeviation = Math.max(topRightX, topRightY, bottomLeftX, bottomLeftY, bottomRightX, bottomRightY);
                            
                            if (maxDeviation > 50) {
                                continue;
                            }
                            
                            // Check angles (90° ±2°)
                            const topEdgeVec = { x: cornerTR.x - cornerTL.x, y: cornerTR.y - cornerTL.y };
                            const leftEdgeVec = { x: cornerBL.x - cornerTL.x, y: cornerBL.y - cornerTL.y };
                            const bottomEdgeVec = { x: cornerBR.x - cornerBL.x, y: cornerBR.y - cornerBL.y };
                            const rightEdgeVec = { x: cornerBR.x - cornerTR.x, y: cornerBR.y - cornerTR.y };
                            
                            const getAngleDeg = (v1, v2) => {
                                const dot = v1.x * v2.x + v1.y * v2.y;
                                const mag1 = Math.sqrt(v1.x * v1.x + v1.y * v1.y);
                                const mag2 = Math.sqrt(v2.x * v2.x + v2.y * v2.y);
                                const cosAngle = dot / (mag1 * mag2);
                                return Math.abs(Math.acos(Math.max(-1, Math.min(1, cosAngle))) * 180 / Math.PI);
                            };
                            
                            const angleTL = getAngleDeg(topEdgeVec, leftEdgeVec);
                            const angleTR = getAngleDeg({ x: -topEdgeVec.x, y: -topEdgeVec.y }, rightEdgeVec);
                            const angleBL = getAngleDeg({ x: -leftEdgeVec.x, y: -leftEdgeVec.y }, bottomEdgeVec);
                            const angleBR = getAngleDeg({ x: -rightEdgeVec.x, y: -rightEdgeVec.y }, { x: -bottomEdgeVec.x, y: -bottomEdgeVec.y });
                            
                            const angleDeviation = Math.max(
                                Math.abs(angleTL - 90),
                                Math.abs(angleTR - 90),
                                Math.abs(angleBL - 90),
                                Math.abs(angleBR - 90)
                            );
                            
                            if (angleDeviation > 2) {
                                continue;
                            }
                            
                            // Check color harmony
                            const frameColors = [
                                cornerTL.hLine.color, cornerTL.vLine.color,
                                cornerTR.hLine.color, cornerTR.vLine.color,
                                cornerBL.hLine.color, cornerBL.vLine.color,
                                cornerBR.hLine.color, cornerBR.vLine.color
                            ];
                            
                            if (!colorsHaveCompatibleHue(frameColors)) {
                                continue;
                            }
                            
                            // Check color similarity
                            const avgColor = {
                                r: frameColors.reduce((sum, c) => sum + c.r, 0) / frameColors.length,
                                g: frameColors.reduce((sum, c) => sum + c.g, 0) / frameColors.length,
                                b: frameColors.reduce((sum, c) => sum + c.b, 0) / frameColors.length
                            };
                            
                            const maxColorDiff = Math.max(...frameColors.map(c => colorDistance(c, avgColor)));
                            
                            if (maxColorDiff > 100) {
                                continue;
                            }
                            
                            // Check corner quality symmetry
                            const cornerQualities = [
                                cornerTL.quality,
                                cornerTR.quality,
                                cornerBL.quality,
                                cornerBR.quality
                            ];
                            
                            const avgQuality = cornerQualities.reduce((sum, q) => sum + q, 0) / 4;
                            const minQuality = Math.min(...cornerQualities);
                            const maxQuality = Math.max(...cornerQualities);
                            
                            const cornerGaps = [
                                cornerTL.gap,
                                cornerTR.gap,
                                cornerBL.gap,
                                cornerBR.gap
                            ];
                            const avgGap = cornerGaps.reduce((sum, g) => sum + g, 0) / 4;
                            
                            if (minQuality < avgQuality * 0.6) {
                                continue;
                            }
                            
                            if (maxQuality - minQuality > 0.5) {
                                continue;
                            }
                            
                            if (avgGap > 3) {
                                continue;
                            }
                            
                            // Calculate score with outermost frame bias
                            const avgContinuity = (cornerTL.avgContinuity + cornerTR.avgContinuity + 
                                                   cornerBL.avgContinuity + cornerBR.avgContinuity) / 4;
                            const avgStrength = (cornerTL.strength + cornerTR.strength + 
                                                cornerBL.strength + cornerBR.strength) / 4;
                            const sizeRatio = (w * h) / (width * height);
                            
                            const avgR = avgColor.r;
                            const avgG = avgColor.g;
                            const avgB = avgColor.b;
                            const luminance = 0.299 * avgR + 0.587 * avgG + 0.114 * avgB;
                            const darknessBonus = 1 + (1 - luminance / 255) * 0.5;
                            const areaBonus = Math.pow(sizeRatio, 1.2);
                            
                            const rectangularityScore = 1 - (maxDeviation / 50);
                            const angleScore = 1 - (angleDeviation / 2);
                            const colorSimilarityBonus = 1 + (1 - maxColorDiff / 100) * 0.3;
                            const cornerQualityBonus = 1 + avgQuality * 0.5;
                            const gapPenalty = 1 - (avgGap / 3);
                            
                            const tlIdealSum = topLeftCandidates[0].x + topLeftCandidates[0].y;
                            const trIdealSum = (width - topRightCandidates[0].x) + topRightCandidates[0].y;
                            const blIdealSum = bottomLeftCandidates[0].x + (height - bottomLeftCandidates[0].y);
                            const brIdealSum = (width - bottomRightCandidates[0].x) + (height - bottomRightCandidates[0].y);
                            
                            const tlDeviation = (cornerTL.x + cornerTL.y) - tlIdealSum;
                            const trDeviation = ((width - cornerTR.x) + cornerTR.y) - trIdealSum;
                            const blDeviation = (cornerBL.x + (height - cornerBL.y)) - blIdealSum;
                            const brDeviation = ((width - cornerBR.x) + (height - cornerBR.y)) - brIdealSum;
                            
                            const maxPositionDeviationFiltered = Math.max(tlDeviation, trDeviation, blDeviation, brDeviation);
                            const positionPenaltyFiltered = 1 / (1 + maxPositionDeviationFiltered / 200);
                            
                            const score = avgContinuity * avgStrength * sizeRatio * areaBonus * rectangularityScore * 
                                          angleScore * darknessBonus * colorSimilarityBonus * cornerQualityBonus * 
                                          gapPenalty * positionPenaltyFiltered * 1000;
                            
                            if (score > bestScore) {
                                bestScore = score;
                                bestFrame = {
                                    x: x,
                                    y: y,
                                    width: w,
                                    height: h,
                                    score: score,
                                    corners: { topLeft: cornerTL, topRight: cornerTR, bottomLeft: cornerBL, bottomRight: cornerBR },
                                    avgContinuity: avgContinuity,
                                    maxDeviation: maxDeviation,
                                    cornerGaps: { TL: cornerTL.gap, TR: cornerTR.gap, BL: cornerBL.gap, BR: cornerBR.gap },
                                    avgGap: avgGap,
                                    avgQuality: avgQuality
                                };
                            }
                        }
                    }
                }
            }
            
            if (!bestFrame) {
                console.log('❌ No valid frame found from corners');
                return null;
            }
            
            // Dynamic line center correction
            const topLine = bestFrame.corners.topLeft.hLine;
            const leftLine = bestFrame.corners.topLeft.vLine;
            const lineThickness = calculateLineThickness(topLine, leftLine, edges, width, height);
            let centerOffset = Math.round(lineThickness / 2);
            centerOffset = Math.max(0, Math.min(1, centerOffset));
            
            console.log(`📏 Dynamic line center correction: thickness=${lineThickness.toFixed(1)}px, offset=${centerOffset}px`);
            
            bestFrame.x += centerOffset;
            bestFrame.y += centerOffset;
            bestFrame.width -= 2 * centerOffset;
            bestFrame.height -= 2 * centerOffset;
            
            console.log(`✅ SELECTED FRAME: (${Math.round(bestFrame.x)}, ${Math.round(bestFrame.y)}) ${Math.round(bestFrame.width)}x${Math.round(bestFrame.height)}`);
            console.log(`   Avg continuity: ${(bestFrame.avgContinuity * 100).toFixed(0)}%, Avg gap: ${bestFrame.avgGap.toFixed(1)}px, Score: ${bestScore.toFixed(1)}`);
            
            return bestFrame;
        }
        
        // Find frame from quadrants - line-based method (from JeppALLIGN v3.18)
        function findFrameFromQuadrants(hLines, vLines, width, height, imageData) {
            // === PODZIEL MAPĘ NA 4 ĆWIARTKI ===
            const midX = width / 2;
            const midY = height / 2;
            const margin = Math.min(width, height) * 0.05; // 5% margines od brzegu
            
            console.log(`Map divided: midX=${Math.round(midX)}, midY=${Math.round(midY)}, margin=${Math.round(margin)}`);
            
            // === EKSTRAKCJA KOLORÓW DLA WSZYSTKICH LINII ===
            console.log('🎨 Extracting line colors...');
            hLines.forEach(line => {
                line.color = extractLineColor(imageData, width, height, line, true);
            });
            vLines.forEach(line => {
                line.color = extractLineColor(imageData, width, height, line, false);
            });
            
            // === ĆWIARTKA 1: GÓRA (TOP) ===
            // Szukamy najbardziej GÓRNEJ solidnej linii (ale NIE przy brzegu kartki!)
            const edgeMargin = Math.max(10, Math.min(width, height) * 0.02); // 10px minimum lub 2% od brzegu
            
            const topCandidates = hLines
                .filter(l => l.y > margin && l.y < midY)
                .filter(l => l.y > edgeMargin) // NIE przy samym brzegu!
                .filter(l => l.x1 > edgeMargin && l.x2 < width - edgeMargin) // końce NIE przy brzegu!
                .sort((a, b) => a.y - b.y); // sortuj od góry
            
            // === ĆWIARTKA 2: DÓŁ (BOTTOM) ===
            const bottomCandidates = hLines
                .filter(l => l.y > midY && l.y < height - margin)
                .filter(l => l.y < height - edgeMargin) // NIE przy samym brzegu!
                .filter(l => l.x1 > edgeMargin && l.x2 < width - edgeMargin) // końce NIE przy brzegu!
                .sort((a, b) => b.y - a.y); // sortuj od dołu
            
            // === ĆWIARTKA 3: LEWA (LEFT) ===
            const leftCandidates = vLines
                .filter(l => l.x > margin && l.x < midX)
                .filter(l => l.x > edgeMargin) // NIE przy samym brzegu!
                .filter(l => l.y1 > edgeMargin && l.y2 < height - edgeMargin) // końce NIE przy brzegu!
                .sort((a, b) => a.x - b.x); // sortuj od lewej
            
            // === ĆWIARTKA 4: PRAWA (RIGHT) ===
            const rightCandidates = vLines
                .filter(l => l.x > midX && l.x < width - margin)
                .filter(l => l.x < width - edgeMargin) // NIE przy samym brzegu!
                .filter(l => l.y1 > edgeMargin && l.y2 < height - edgeMargin) // końce NIE przy brzegu!
                .sort((a, b) => b.x - a.x); // sortuj od prawej
            
            console.log(`Edge margin: ${Math.round(edgeMargin)}px (lines within this distance from edge are rejected)`);
            console.log(`Quadrant candidates: TOP=${topCandidates.length}, BOTTOM=${bottomCandidates.length}, LEFT=${leftCandidates.length}, RIGHT=${rightCandidates.length}`);
            
            if (topCandidates.length === 0 || bottomCandidates.length === 0 || 
                leftCandidates.length === 0 || rightCandidates.length === 0) {
                console.log('⚠️ Missing lines in some quadrants, using fallback');
                return {
                    x: margin, y: margin,
                    width: width - 2 * margin,
                    height: height - 2 * margin,
                    score: 0, cornersConnected: 0, avgContinuity: 0
                };
            }
            
            // === TESTUJ KOMBINACJE: weź top 3 z każdej ćwiartki ===
            let bestFrame = null;
            let bestScore = 0;
            
            for (let ti = 0; ti < Math.min(3, topCandidates.length); ti++) {
                for (let bi = 0; bi < Math.min(3, bottomCandidates.length); bi++) {
                    const topLine = topCandidates[ti];
                    const bottomLine = bottomCandidates[bi];
                    const h = bottomLine.y - topLine.y;
                    
                    // Ramka musi mieć sensowny rozmiar
                    if (h < height * 0.4 || h > height * 0.95) continue;
                    
                    for (let li = 0; li < Math.min(3, leftCandidates.length); li++) {
                        for (let ri = 0; ri < Math.min(3, rightCandidates.length); ri++) {
                            const leftLine = leftCandidates[li];
                            const rightLine = rightCandidates[ri];
                            const w = rightLine.x - leftLine.x;
                            
                            if (w < width * 0.4 || w > width * 0.95) continue;
                            
                            const aspectRatio = w / h;
                            if (aspectRatio < 0.6 || aspectRatio > 2.8) continue;
                            
                            // === SPRAWDŹ CZY TO JEST FAKTYCZNY PROSTOKĄT ===
                            
                            // KROK 1: Sprawdź czy linie poziome mają podobną długość
                            const topLength = topLine.x2 - topLine.x1;
                            const bottomLength = bottomLine.x2 - bottomLine.x1;
                            const hLengthDiff = Math.abs(topLength - bottomLength);
                            
                            if (hLengthDiff > Math.min(topLength, bottomLength) * 0.15) {
                                // Różnica > 15% → to nie prostokąt!
                                continue;
                            }
                            
                            // KROK 2: Sprawdź czy linie pionowe mają podobną długość
                            const leftLength = leftLine.y2 - leftLine.y1;
                            const rightLength = rightLine.y2 - rightLine.y1;
                            const vLengthDiff = Math.abs(leftLength - rightLength);
                            
                            if (vLengthDiff > Math.min(leftLength, rightLength) * 0.15) {
                                // Różnica > 15% → to nie prostokąt!
                                continue;
                            }
                            
                            // KROK 3: OSTRO sprawdź wszystkie 4 narożniki
                            // Każdy róg MUSI mieć zarówno X jak i Y pasujące!
                            let cornersConnected = 0;
                            const cornerTolerance = 15;
                            
                            // Top-left: linia TOP zaczyna się (x1) TAM gdzie linia LEFT jest (x)
                            //           oraz linia LEFT zaczyna się (y1) TAM gdzie linia TOP jest (y)
                            if (Math.abs(topLine.x1 - leftLine.x) <= cornerTolerance &&
                                Math.abs(leftLine.y1 - topLine.y) <= cornerTolerance) {
                                cornersConnected++;
                            }
                            
                            // Top-right: linia TOP kończy się (x2) TAM gdzie linia RIGHT jest (x)
                            //            oraz linia RIGHT zaczyna się (y1) TAM gdzie linia TOP jest (y)
                            if (Math.abs(topLine.x2 - rightLine.x) <= cornerTolerance &&
                                Math.abs(rightLine.y1 - topLine.y) <= cornerTolerance) {
                                cornersConnected++;
                            }
                            
                            // Bottom-left: linia BOTTOM zaczyna się (x1) TAM gdzie linia LEFT jest (x)
                            //              oraz linia LEFT kończy się (y2) TAM gdzie linia BOTTOM jest (y)
                            if (Math.abs(bottomLine.x1 - leftLine.x) <= cornerTolerance &&
                                Math.abs(leftLine.y2 - bottomLine.y) <= cornerTolerance) {
                                cornersConnected++;
                            }
                            
                            // Bottom-right: linia BOTTOM kończy się (x2) TAM gdzie linia RIGHT jest (x)
                            //               oraz linia RIGHT kończy się (y2) TAM gdzie linia BOTTOM jest (y)
                            if (Math.abs(bottomLine.x2 - rightLine.x) <= cornerTolerance &&
                                Math.abs(rightLine.y2 - bottomLine.y) <= cornerTolerance) {
                                cornersConnected++;
                            }
                            
                            // WYMAGANE: WSZYSTKIE 4 NAROŻNIKI! (nie 3/4)
                            if (cornersConnected < 4) {
                                if (cornersConnected >= 3) {
                                    console.log(`⚠️ Rejected: only ${cornersConnected}/4 corners (required 4/4 for solid rectangle)`);
                                }
                                continue;
                            }
                            
                            // KROK 4: Sprawdź czy linie ZAWIERAJĄ cały zakres prostokąta
                            // Linia TOP musi sięgać od LEFT.x do RIGHT.x
                            const topCoversWidth = (topLine.x1 <= leftLine.x + cornerTolerance) && 
                                                   (topLine.x2 >= rightLine.x - cornerTolerance);
                            
                            // Linia BOTTOM musi sięgać od LEFT.x do RIGHT.x
                            const bottomCoversWidth = (bottomLine.x1 <= leftLine.x + cornerTolerance) && 
                                                      (bottomLine.x2 >= rightLine.x - cornerTolerance);
                            
                            // Linia LEFT musi sięgać od TOP.y do BOTTOM.y
                            const leftCoversHeight = (leftLine.y1 <= topLine.y + cornerTolerance) && 
                                                     (leftLine.y2 >= bottomLine.y - cornerTolerance);
                            
                            // Linia RIGHT musi sięgać od TOP.y do BOTTOM.y
                            const rightCoversHeight = (rightLine.y1 <= topLine.y + cornerTolerance) && 
                                                      (rightLine.y2 >= bottomLine.y - cornerTolerance);
                            
                            if (!topCoversWidth || !bottomCoversWidth || !leftCoversHeight || !rightCoversHeight) {
                                console.log(`⚠️ Rejected: lines don't cover full rectangle`);
                                continue;
                            }
                            
                            // === KLUCZOWE: SPRAWDŹ PODOBIEŃSTWO KOLORÓW ===
                            // Ramka musi składać się z linii tego samego koloru!
                            
                            // KROK 1: Sprawdź harmonię kolorystyczną (charakter koloru)
                            const frameColors = [topLine.color, bottomLine.color, leftLine.color, rightLine.color];
                            if (!colorsHaveCompatibleHue(frameColors)) {
                                console.log(`❌ Rejected frame: incompatible color hues (neutral vs saturated)`);
                                continue;
                            }
                            
                            // KROK 2: Sprawdź odległość RGB (różne odcienie tego samego typu)
                            const colorThreshold = 100; // zwiększone z 50 do 100 dla odcieni szarości
                            
                            // Oblicz średni kolor z 4 linii
                            const avgColor = {
                                r: (topLine.color.r + bottomLine.color.r + leftLine.color.r + rightLine.color.r) / 4,
                                g: (topLine.color.g + bottomLine.color.g + leftLine.color.g + rightLine.color.g) / 4,
                                b: (topLine.color.b + bottomLine.color.b + leftLine.color.b + rightLine.color.b) / 4
                            };
                            
                            // Sprawdź czy wszystkie linie są zbliżone kolorystycznie do średniej
                            const topColorDiff = colorDistance(topLine.color, avgColor);
                            const bottomColorDiff = colorDistance(bottomLine.color, avgColor);
                            const leftColorDiff = colorDistance(leftLine.color, avgColor);
                            const rightColorDiff = colorDistance(rightLine.color, avgColor);
                            
                            const maxColorDiff = Math.max(topColorDiff, bottomColorDiff, leftColorDiff, rightColorDiff);
                            
                            // Jeśli któraś linia ma drastycznie inny odcień - odrzuć tę kombinację!
                            if (maxColorDiff > colorThreshold) {
                                console.log(`❌ Rejected frame: color distance too large (max diff=${maxColorDiff.toFixed(0)} > ${colorThreshold})`);
                                continue;
                            }
                            
                            // Bonus za bardzo podobne odcienie
                            const colorSimilarityBonus = 1 + (1 - maxColorDiff / colorThreshold) * 0.3; // max +30%
                            
                            // === SCORING ===
                            const avgContinuity = (topLine.continuity + bottomLine.continuity + 
                                                   leftLine.continuity + rightLine.continuity) / 4;
                            const sizeRatio = (w * h) / (width * height);
                            const cornerBonus = Math.pow(cornersConnected / 4, 1.5);
                            
                            // BONUS za zewnętrzność (ale w ramach ćwiartek!)
                            const topness = 1 - (topLine.y / midY);      // im bliżej góry, tym lepiej
                            const bottomness = 1 - ((height - bottomLine.y) / midY);
                            const leftness = 1 - (leftLine.x / midX);
                            const rightness = 1 - ((width - rightLine.x) / midX);
                            const outernessBonus = (topness + bottomness + leftness + rightness) / 4;
                            
                            const score = cornerBonus * avgContinuity * sizeRatio * (1 + outernessBonus) * colorSimilarityBonus * 1000;
                            
                            if (score > bestScore) {
                                bestScore = score;
                                bestFrame = {
                                    x: leftLine.x,
                                    y: topLine.y,
                                    width: w,
                                    height: h,
                                    score: score,
                                    cornersConnected: cornersConnected,
                                    avgContinuity: avgContinuity,
                                    lines: { top: topLine, bottom: bottomLine, left: leftLine, right: rightLine }
                                };
                            }
                        }
                    }
                }
            }
            
            if (!bestFrame) {
                console.log('❌ NO VALID FRAME FOUND!');
                console.log('   Reason: No rectangle with 4/4 connected corners detected.');
                console.log('   This means the detected lines do not form a proper closed rectangle.');
                return null;
            }
            
            console.log(`✅ SELECTED FRAME:`);
            console.log(`   Position: (${Math.round(bestFrame.x)}, ${Math.round(bestFrame.y)})`);
            console.log(`   Size: ${Math.round(bestFrame.width)} x ${Math.round(bestFrame.height)}`);
            console.log(`   Corners: ${bestFrame.cornersConnected}/4 connected`);
            console.log(`   Continuity: ${(bestFrame.avgContinuity * 100).toFixed(0)}%`);
            console.log(`   Score: ${bestScore.toFixed(1)}`);
            
            // Debug: pokaż kolory linii ramki
            if (bestFrame.lines) {
                const avgR = Math.round((bestFrame.lines.top.color.r + bestFrame.lines.bottom.color.r + 
                                        bestFrame.lines.left.color.r + bestFrame.lines.right.color.r) / 4);
                const avgG = Math.round((bestFrame.lines.top.color.g + bestFrame.lines.bottom.color.g + 
                                        bestFrame.lines.left.color.g + bestFrame.lines.right.color.g) / 4);
                const avgB = Math.round((bestFrame.lines.top.color.b + bestFrame.lines.bottom.color.b + 
                                        bestFrame.lines.left.color.b + bestFrame.lines.right.color.b) / 4);
                console.log(`   Frame color: RGB(${avgR}, ${avgG}, ${avgB})`);
            }
            
            return bestFrame;
        }
        
        // Best chart frame detection (from JeppALLIGN v3.18)
        function findBestChartFrame(hLines, vLines, width, height, imageData, edges) {
            console.log('═══════════════════════════════════════════');
            console.log('  JeppALLIGN v3.18 - Frame Detection      ');
            console.log('═══════════════════════════════════════════');
            
            console.log(`Input lines: ${hLines.length} H-lines, ${vLines.length} V-lines`);
            
            // Krok 1: Wykryj wszystkie narożniki
            const corners = detectCorners(hLines, vLines, 10);
            
            if (corners.length < 4) {
                console.log(`⚠️ Not enough corners detected (${corners.length}), falling back to line-based detection`);
                // Fallback do starej metody
                const solidH = hLines.filter(l => l.continuity > 0.7);
                const solidV = vLines.filter(l => l.continuity > 0.7);
                
                if (solidH.length >= 2 && solidV.length >= 2) {
                    return findFrameFromQuadrants(solidH, solidV, width, height, imageData);
                }
                
                return null;
            }
            
            // Krok 2: Znajdź ramkę z narożników
            const frameFromCorners = findFrameFromCorners(corners, width, height, imageData, edges);
            
            if (frameFromCorners) {
                return frameFromCorners;
            }
            
            // Fallback: Jeśli corner detection zawiódł, spróbuj line-based
            console.log('⚠️ Corner-based detection failed, trying line-based detection...');
            const solidH = hLines.filter(l => l.continuity > 0.85);
            const solidV = vLines.filter(l => l.continuity > 0.85);
            
            console.log(`Solid lines: ${solidH.length} H-lines, ${solidV.length} V-lines (continuity >85%)`);
            
            if (solidH.length < 2 || solidV.length < 2) {
                console.log('⚠️ Not enough solid lines, lowering threshold to 70%');
                const fallbackH = hLines.filter(l => l.continuity > 0.7);
                const fallbackV = vLines.filter(l => l.continuity > 0.7);
                return findFrameFromQuadrants(fallbackH, fallbackV, width, height, imageData);
            }
            
            return findFrameFromQuadrants(solidH, solidV, width, height, imageData);
        }

        function detectContentBBox(ctx, width, height) {
            const imageData = ctx.getImageData(0, 0, width, height);
            const data = imageData.data;
            
            const threshold = 240;
            
            let minX = width, maxX = 0;
            let minY = height, maxY = 0;
            
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const i = (y * width + x) * 4;
                    const r = data[i];
                    const g = data[i + 1];
                    const b = data[i + 2];
                    
                    if (r < threshold || g < threshold || b < threshold) {
                        minX = Math.min(minX, x);
                        maxX = Math.max(maxX, x);
                        minY = Math.min(minY, y);
                        maxY = Math.max(maxY, y);
                    }
                }
            }
            
            const padding = 10;
            return {
                x: Math.max(0, minX - padding),
                y: Math.max(0, minY - padding),
                width: Math.min(width, maxX + padding) - Math.max(0, minX - padding),
                height: Math.min(height, maxY + padding) - Math.max(0, minY - padding)
            };
        }

        async function extractPDFAnnotations(pdfDoc, pageNum) {
            try {
                const page = await pdfDoc.getPage(pageNum);
                const annotations = await page.getAnnotations();
                
                const results = [];
                for (const annotation of annotations) {
                    if (annotation.subtype === 'Text' || annotation.subtype === 'FreeText' || annotation.subtype === 'Popup') {
                        // Próbuj różne właściwości dla treści
                        const contents = annotation.contents 
                            || annotation.contentsObj?.str 
                            || annotation.richText 
                            || annotation.rc 
                            || '';
                        
                        const title = annotation.title 
                            || annotation.titleObj?.str 
                            || annotation.name 
                            || 'Komentarz';
                        
                        if (contents || title !== 'Komentarz') {
                            results.push({
                                type: annotation.subtype,
                                rect: annotation.rect,
                                contents: contents,
                                title: title,
                                raw: annotation // dla debugowania
                            });
                        }
                    }
                }
                
                // Log dla debugowania
                if (results.length > 0) {
                    console.log('Znaleziono annotacje:', results);
                }
                
                return results;
            } catch (error) {
                console.error('Error extracting annotations:', error);
                return [];
            }
        }

        // Renderowanie adnotacji PDF z prawidłowym skalowaniem
        async function renderPDFAnnotations(container, pdfDoc, pageNum, canvasWidth, canvasHeight) {
            const annotations = await extractPDFAnnotations(pdfDoc, pageNum);
            
            // Pobierz stronę aby uzyskać oryginalny viewport
            const page = await pdfDoc.getPage(pageNum);
            const viewport = page.getViewport({scale: getRenderScale()}); // Dynamiczna skala
            
            // Oblicz skalę między oryginalnym viewport a canvas
            const scaleX = canvasWidth / viewport.width;
            const scaleY = canvasHeight / viewport.height;
            
            annotations.forEach(annot => {
                const annotDiv = document.createElement('div');
                annotDiv.className = 'pdf-annotation';
                
                // Przelicz pozycję z PDF coords na canvas coords
                const x = annot.rect[0] * scaleX;
                const y = canvasHeight - (annot.rect[3] * scaleY);
                
                annotDiv.style.left = x + 'px';
                annotDiv.style.top = y + 'px';
                
                const icon = document.createElement('div');
                icon.className = 'pdf-annotation-icon';
                icon.textContent = '💬';
                annotDiv.appendChild(icon);
                
                const popup = document.createElement('div');
                popup.className = 'pdf-annotation-popup';
                popup.style.display = 'none'; // Domyślnie ukryty
                
                // Zawartość popupu
                const title = annot.title || 'Komentarz';
                const content = annot.contents || '(brak treści)';
                popup.innerHTML = `<strong>${title}:</strong> ${content}`;
                
                // Kliknięcie = toggle widoczności (sticky)
                let isPopupVisible = false;
                annotDiv.addEventListener('click', (e) => {
                    e.stopPropagation();
                    isPopupVisible = !isPopupVisible;
                    
                    if (isPopupVisible) {
                        popup.style.display = 'block';
                        popup.style.left = (e.clientX + 15) + 'px';
                        popup.style.top = (e.clientY + 15) + 'px';
                    } else {
                        popup.style.display = 'none';
                    }
                });
                
                // Kliknięcie w popup zamyka go
                popup.addEventListener('click', (e) => {
                    e.stopPropagation();
                    isPopupVisible = false;
                    popup.style.display = 'none';
                });
                
                document.body.appendChild(popup);
                container.appendChild(annotDiv);
            });
        }

        function comparePixels(oldCanvas, newCanvas, pageNum) {
            const differences = [];
            const sensitivityValue = document.getElementById('sensitivityRange').value;
            
            // ODWRÓCONA LOGIKA - intuicyjna:
            // Im WYŻSZA czułość (100%), tym NIŻSZY threshold, tym WIĘCEJ wykrywa
            // 100% czułości → threshold 0 (wykrywa wszystko, nawet małe różnice)
            // 0% czułości → threshold 255 (wykrywa mało, tylko duże różnice)
            const threshold = (100 - sensitivityValue) * 2.55;
            
            // Obniżone minArea - wykrywa mniejsze regiony
            const minArea = 5;
            
            const coordinateScale = 1.5;
            
            const oldCtx = oldCanvas.getContext('2d', { willReadFrequently: true });
            const newCtx = newCanvas.getContext('2d', { willReadFrequently: true });
            
            const oldData = oldCtx.getImageData(0, 0, oldCanvas.width, oldCanvas.height);
            const newData = newCtx.getImageData(0, 0, newCanvas.width, newCanvas.height);
            
            const width = Math.min(oldCanvas.width, newCanvas.width);
            const height = Math.min(oldCanvas.height, newCanvas.height);
            
            // Tworzymy nowy canvas z różnicami - bezpośrednie kolorowanie
            const diffCanvas = document.createElement('canvas');
            diffCanvas.width = width;
            diffCanvas.height = height;
            const diffCtx = diffCanvas.getContext('2d');
            const diffData = diffCtx.createImageData(width, height);
            
            let differenceCount = 0;
            const diffMap = new Uint8Array(width * height); // Mapa pikseli z różnicami dla flood fill
            
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const i = (y * width + x) * 4;
                    
                    const r1 = oldData.data[i];
                    const g1 = oldData.data[i + 1];
                    const b1 = oldData.data[i + 2];
                    
                    const r2 = newData.data[i];
                    const g2 = newData.data[i + 1];
                    const b2 = newData.data[i + 2];
                    
                    // Oblicz luminance (jasność) dla OLD i NEW
                    const luminance1 = 0.299 * r1 + 0.587 * g1 + 0.114 * b1;
                    const luminance2 = 0.299 * r2 + 0.587 * g2 + 0.114 * b2;
                    
                    // Progi jasności - złagodzone dla lepszego wykrywania
                    const veryDarkThreshold = 80;   // Poniżej = bardzo ciemny
                    const veryLightThreshold = 175; // Powyżej = bardzo jasny
                    
                    const isVeryDark1 = luminance1 < veryDarkThreshold;
                    const isVeryLight1 = luminance1 > veryLightThreshold;
                    const isVeryDark2 = luminance2 < veryDarkThreshold;
                    const isVeryLight2 = luminance2 > veryLightThreshold;
                    
                    // Wykrywaj TYLKO zmiany: bardzo jasny↔bardzo ciemny
                    const isLightToDark = isVeryLight1 && isVeryDark2; // bardzo jasny→bardzo ciemny
                    const isDarkToLight = isVeryDark1 && isVeryLight2; // bardzo ciemny→bardzo jasny
                    
                    const diff = Math.abs(r1 - r2) + Math.abs(g1 - g2) + Math.abs(b1 - b2);
                    
                    if (diff > threshold && (isLightToDark || isDarkToLight)) {
                        differenceCount++;
                        diffMap[y * width + x] = 1; // Oznacz piksel jako różny
                        
                        // Pozostaw piksel PRZEZROCZYSTY - usunięte pomarańczowe oznaczenia
                        diffData.data[i] = 0;
                        diffData.data[i + 1] = 0;
                        diffData.data[i + 2] = 0;
                        diffData.data[i + 3] = 0;    // Alpha = 0 (przezroczyste)
                    } else {
                        // PRZEZROCZYSTOŚĆ - żeby było widać mapy przełączające się pod spodem
                        diffData.data[i] = 0;
                        diffData.data[i + 1] = 0;
                        diffData.data[i + 2] = 0;
                        diffData.data[i + 3] = 0;    // Alpha = 0 (całkowicie przezroczyste)
                    }
                }
            }
            
            diffCtx.putImageData(diffData, 0, 0);
            
            // Znajdź regiony zmian dla żółtych kółek
            const regions = [];
            const visited = new Uint8Array(width * height);
            
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const idx = y * width + x;
                    if (diffMap[idx] === 1 && visited[idx] === 0) {
                        const region = floodFill(diffMap, visited, x, y, width, height);
                        
                        // Filtruj według stałego minArea
                        if (region.area >= minArea) {
                            regions.push({
                                centerX: (region.minX + region.maxX) / 2,
                                centerY: (region.minY + region.maxY) / 2,
                                width: region.maxX - region.minX,
                                height: region.maxY - region.minY,
                                area: region.area,
                                minX: region.minX,
                                maxX: region.maxX,
                                minY: region.minY,
                                maxY: region.maxY
                            });
                        }
                    }
                }
            }
            
            // KLUCZOWE: Nałóż żółty zakreślacz BEZPOŚREDNIO na piksele - tylko na jasne obszary!
            if (regions.length > 0) {
                // Pobierz dane z diffCanvas
                const finalDiffData = diffCtx.getImageData(0, 0, width, height);
                
                regions.forEach(region => {
                    const regionSize = Math.max(region.width, region.height);
                    let baseRadius = regionSize * 0.9;
                    baseRadius = Math.max(baseRadius, 25);
                    
                    // Dla każdego piksela w bounding box regionu
                    for (let y = Math.max(0, Math.floor(region.minY - baseRadius)); y <= Math.min(height - 1, Math.ceil(region.maxY + baseRadius)); y++) {
                        for (let x = Math.max(0, Math.floor(region.minX - baseRadius)); x <= Math.min(width - 1, Math.ceil(region.maxX + baseRadius)); x++) {
                            // Sprawdź czy piksel jest w którymś kółku tego regionu
                            let inCircle = false;
                            
                            if (regionSize > 60) {
                                const numCirclesX = Math.ceil(region.width / 45);
                                const numCirclesY = Math.ceil(region.height / 45);
                                
                                for (let cy = 0; cy < numCirclesY && !inCircle; cy++) {
                                    for (let cx = 0; cx < numCirclesX && !inCircle; cx++) {
                                        const circleX = region.minX + (cx + 0.5) * (region.width / numCirclesX);
                                        const circleY = region.minY + (cy + 0.5) * (region.height / numCirclesY);
                                        const dist = Math.sqrt((x - circleX) ** 2 + (y - circleY) ** 2);
                                        if (dist <= 28) inCircle = true;
                                    }
                                }
                            } else {
                                const dist = Math.sqrt((x - region.centerX) ** 2 + (y - region.centerY) ** 2);
                                if (dist <= baseRadius) inCircle = true;
                            }
                            
                            if (inCircle) {
                                const i = (y * width + x) * 4;
                                const idx = y * width + x;
                                
                                // KLUCZOWE: Jeśli piksel jest w obszarze różnic (diffMap === 1) - NIE nakładaj żółtego!
                                // To pozwala czarnemu tekstowi (różnicom) przebijać się w 100%
                                if (diffMap[idx] === 1) continue;
                                
                                // Pobierz oryginalny piksel z NEW mapy
                                const origR = newData.data[i];
                                const origG = newData.data[i + 1];
                                const origB = newData.data[i + 2];
                                
                                // Oblicz luminance (jasność)
                                const luminance = 0.299 * origR + 0.587 * origG + 0.114 * origB;
                                
                                // TYLKO na jasne piksele (luminance > 80) nałóż żółty zakreślacz!
                                // Ciemne piksele (czarny tekst) zostają PRZEZROCZYSTE - przebijają się w 100%!
                                if (luminance > 80) {
                                    // Żółty z przezroczystością - jak marker highlighter
                                    finalDiffData.data[i] = 255;      // R
                                    finalDiffData.data[i + 1] = 255;  // G
                                    finalDiffData.data[i + 2] = 0;    // B - żółty
                                    finalDiffData.data[i + 3] = 150;  // Alpha 150
                                }
                            }
                        }
                    }
                });
                
                // Wstaw zmodyfikowane dane
                diffCtx.putImageData(finalDiffData, 0, 0);
            }
            
            // Zwracamy informację o różnicach
            if (differenceCount > 0) {
                differences.push({
                    type: 'graphic',
                    page: pageNum,
                    x: 0,
                    y: 0,
                    width: width,
                    height: height,
                    diffCanvas: diffCanvas,  // Canvas z różnicami
                    diffCount: differenceCount,
                    totalPixels: width * height,
                    percentage: (differenceCount / (width * height)) * 100,
                    regions: regions,
                    threshold: threshold,  // Dodajemy info o threshold
                    minArea: minArea
                });
            }
            
            return differences;
        }

        function floodFill(map, visited, startX, startY, width, height) {
            const stack = [[startX, startY]];
            let area = 0;
            let minX = startX, maxX = startX;
            let minY = startY, maxY = startY;
            
            while (stack.length > 0) {
                const [x, y] = stack.pop();
                const idx = y * width + x;
                
                if (x < 0 || x >= width || y < 0 || y >= height) continue;
                if (visited[idx] === 1 || map[idx] === 0) continue;
                
                visited[idx] = 1;
                area++;
                
                minX = Math.min(minX, x);
                maxX = Math.max(maxX, x);
                minY = Math.min(minY, y);
                maxY = Math.max(maxY, y);
                
                stack.push([x + 1, y], [x - 1, y], [x, y + 1], [x, y - 1]);
            }
            
            return { area, minX, maxX, minY, maxY };
        }

        async function toggleOCRMode(mode) {
            const hybridBtn = document.getElementById('ocrHybridBtn');
            const sensitivityControl = document.getElementById('sensitivityControl');
            
            if (ocrMode === mode) {
                ocrMode = null;
                hybridBtn.classList.remove('active');
                sensitivityControl.style.display = 'none';
                clearOCROverlay();
            } else {
                ocrMode = mode;
                hybridBtn.classList.toggle('active', mode === 'hybrid');
                sensitivityControl.style.display = mode === 'hybrid' ? 'block' : 'none';
                await renderOCROverlay();
            }
        }

        async function renderOCROverlay() {
            if (!ocrMode || currentPairIndex >= pdfPairs.length) {
                clearOCROverlay();
                return;
            }
            
            let ocrData = ocrResults.get(currentPairIndex);
            
            // Jeśli nie ma canvasów, przygotuj je
            if (!ocrData) {
                await prepareCanvasesForPixelDiff(currentPairIndex);
                ocrData = ocrResults.get(currentPairIndex);
            }
            
            if (!ocrData) {
                clearOCROverlay();
                return;
            }
            
            document.querySelectorAll('.ocr-overlay').forEach(el => el.remove());
            
            const currentPage = currentPageIndex + 1;
            
            if (currentMode === 'sidebyside') {
                const oldContainer = document.getElementById('oldContainer');
                const newContainer = document.getElementById('newContainer');
                
                if (oldContainer) {
                    const oldCanvas = oldContainer.querySelector('canvas');
                    if (oldCanvas) {
                        const overlay = createOCROverlaySVG(oldCanvas, ocrData, currentPage);
                        oldContainer.appendChild(overlay);
                    }
                }
                
                if (newContainer) {
                    const newCanvas = newContainer.querySelector('canvas');
                    if (newCanvas) {
                        const overlay = createOCROverlaySVG(newCanvas, ocrData, currentPage);
                        newContainer.appendChild(overlay);
                    }
                }
            } else if (currentMode === 'toggle') {
                // W TRYBIE TOGGLE: dodaj JEDEN overlay do toggleContainer
                const toggleContainer = document.getElementById('toggleContainer');
                
                if (toggleContainer) {
                    // Znajdź pierwszy canvas (może być old lub new)
                    const canvas = toggleContainer.querySelector('canvas');
                    if (canvas) {
                        const overlay = createOCROverlaySVG(canvas, ocrData, currentPage);
                        toggleContainer.appendChild(overlay);
                    }
                }
            } else {
                // Inne tryby (overlay)
                const container = document.querySelector('.canvas-container');
                if (container) {
                    const canvas = container.querySelector('canvas');
                    if (canvas) {
                        const overlay = createOCROverlaySVG(canvas, ocrData, currentPage);
                        container.appendChild(overlay);
                    }
                }
            }
        }

        function createOCROverlaySVG(canvas, ocrData, currentPage) {
            const container = document.createElement('div');
            container.classList.add('ocr-overlay');
            container.style.position = 'absolute';
            container.style.top = '0';
            container.style.left = '0';
            container.style.width = '100%';
            container.style.height = '100%';
            container.style.pointerEvents = 'none';
            container.style.zIndex = '998';
            
            if (ocrMode === 'hybrid') {
                const pair = pdfPairs[currentPairIndex];
                
                const loadingText = document.createElement('div');
                loadingText.style.position = 'absolute';
                loadingText.style.top = '10px';
                loadingText.style.left = '10px';
                loadingText.style.color = '#ffa500';
                loadingText.style.fontSize = '20px';
                loadingText.style.fontWeight = 'bold';
                loadingText.style.background = 'rgba(0,0,0,0.8)';
                loadingText.style.padding = '10px';
                loadingText.style.borderRadius = '5px';
                loadingText.textContent = 'Obliczam pixel diff...';
                loadingText.classList.add('pixel-diff-loading');
                container.appendChild(loadingText);
                
                recalculatePixelDiff(pair, currentPage).then(pixelDiffs => {
                    container.querySelectorAll('.pixel-diff-loading').forEach(el => el.remove());
                    
                    if (pixelDiffs.length > 0 && pixelDiffs[0].diffCanvas) {
                        const diff = pixelDiffs[0];
                        const diffCanvas = diff.diffCanvas;
                        
                        // Dodaj canvas z różnicami jako overlay
                        diffCanvas.style.position = 'absolute';
                        diffCanvas.style.top = '0';
                        diffCanvas.style.left = '0';
                        diffCanvas.style.width = '100%';
                        diffCanvas.style.height = '100%';
                        diffCanvas.style.pointerEvents = 'none';
                        diffCanvas.style.zIndex = '999';
                        container.appendChild(diffCanvas);
                        
                        // Żółty zakreślacz jest już namalowany BEZPOŚREDNIO w diffCanvas!
                    }
                });
            }
            
            return container;
        }

        async function prepareCanvasesForPixelDiff(pairIndex) {
            if (pairIndex >= pdfPairs.length) return;
            
            const pair = pdfPairs[pairIndex];
            
            try {
                const pixelData = {
                    canvases: []
                };
                
                for (let pageNum = 1; pageNum <= pair.totalPages; pageNum++) {
                    const oldCanvas = document.createElement('canvas');
                    const newCanvas = document.createElement('canvas');
                    
                    const scale = 2.0;
                    
                    if (pageNum <= pair.oldDoc.numPages) {
                        const page = await pair.oldDoc.getPage(pageNum);
                        const viewport = page.getViewport({scale: scale});
                        oldCanvas.width = viewport.width;
                        oldCanvas.height = viewport.height;
                        const ctx = oldCanvas.getContext('2d');
                        await page.render({canvasContext: ctx, viewport: viewport}).promise;
                    }
                    
                    if (pageNum <= pair.newDoc.numPages) {
                        const page = await pair.newDoc.getPage(pageNum);
                        const viewport = page.getViewport({scale: scale});
                        newCanvas.width = viewport.width;
                        newCanvas.height = viewport.height;
                        const ctx = newCanvas.getContext('2d');
                        await page.render({canvasContext: ctx, viewport: viewport}).promise;
                    }
                    
                    pixelData.canvases.push({
                        page: pageNum,
                        oldCanvas: oldCanvas,
                        newCanvas: newCanvas
                    });
                }
                
                ocrResults.set(pairIndex, pixelData);
                
            } catch (error) {
                console.error(`Error preparing canvases for pair ${pairIndex}:`, error);
            }
        }

        async function recalculatePixelDiff(pair, pageNum) {
            const ocrData = ocrResults.get(currentPairIndex);
            if (!ocrData || !ocrData.canvases) {
                return [];
            }
            
            const canvasData = ocrData.canvases.find(c => c.page === pageNum);
            if (!canvasData) {
                return [];
            }
            
            return comparePixels(canvasData.oldCanvas, canvasData.newCanvas, pageNum);
        }

        function clearOCROverlay() {
            document.querySelectorAll('.ocr-overlay').forEach(el => el.remove());
        }

        // FIX #3: Add "NO ICAO" group for pairs without ICAO
        function renderPairList() {
            const pairList = document.getElementById('pairListSidebar');
            pairList.innerHTML = '';

            const icaoGroups = new Map();
            pdfPairs.forEach((pair, index) => {
                const icao = pair.icao || 'NO ICAO';
                if (!icaoGroups.has(icao)) icaoGroups.set(icao, []);
                icaoGroups.get(icao).push({ pair, index });
            });

            // Sort groups: regular ICAOs first, then NO ICAO
            const sortedICAOs = Array.from(icaoGroups.keys()).sort((a, b) => {
                if (a === 'NO ICAO') return 1;
                if (b === 'NO ICAO') return -1;
                return a.localeCompare(b);
            });

            sortedICAOs.forEach((icao) => {
                const items = icaoGroups.get(icao);
                const groupDiv = document.createElement('div');
                groupDiv.className = 'icao-group';

                const header = document.createElement('div');
                header.className = icao === 'NO ICAO' ? 'icao-header no-icao' : 'icao-header';
                const icon = icao === 'NO ICAO' ? '⚠️' : '✈️';
                header.innerHTML = `<span>${icon} ${icao} (${items.length})</span><span class="arrow">▼</span>`;
                header.onclick = (e) => {
                    e.stopPropagation();
                    header.classList.toggle('collapsed');
                    filesDiv.classList.toggle('hidden');
                };
                groupDiv.appendChild(header);

                const filesDiv = document.createElement('div');
                filesDiv.className = 'icao-files';

                items.forEach(({ pair, index }) => {
                    const itemDiv = document.createElement('div');
                    itemDiv.className = 'pair-item-sidebar';
                    if (index === currentPairIndex && selectedUnpairedOldIndex === null && selectedUnpairedNewIndex === null) {
                        itemDiv.classList.add('active');
                    }
                    if (checkedPairs.has(index)) itemDiv.classList.add('checked');

                    const checkbox = document.createElement('div');
                    checkbox.className = 'checkbox';
                    checkbox.onclick = (e) => {
                        e.stopPropagation();
                        toggleCheckbox(index);
                    };

                    const nameDiv = document.createElement('div');
                    nameDiv.className = 'pair-name';
                    
                    let displayName = pair.name.replace(/^AD\s*2-?/i, '').trim();
                    // Usuń rozszerzenie .pdf
                    displayName = displayName.replace(/\.pdf$/i, '');
                    if (pair.icao && pair.icao !== 'NO ICAO') {
                        displayName = displayName.replace(new RegExp(`^${pair.icao}[\\s-]*`, 'i'), '').trim();
                    }
                    
                    nameDiv.innerHTML = `
                        <div class="pair-name-main">${index + 1}. ${displayName}</div>
                        <div class="pair-name-pages">${pair.totalPages}s</div>
                    `;

                    let warningIcon = null;
                    if (pair.fuzzyDistance && pair.fuzzyDistance > 0) {
                        warningIcon = document.createElement('span');
                        warningIcon.className = 'fuzzy-warning';
                        warningIcon.textContent = '⚠️';
                        warningIcon.setAttribute('data-tooltip', 'Nazwa dopasowana funkcją fuzzy matching. Upewnij się, że mapy są dobrze sparowane!');
                    }

                    // Usunięto ocrStatus - nie potrzebny dla pixel diff

                    const removeBtn = document.createElement('button');
                    removeBtn.className = 'remove-pair-btn';
                    removeBtn.textContent = '❌';
                    removeBtn.title = 'Usuń parę';
                    removeBtn.onclick = (e) => {
                        e.stopPropagation();
                        if (confirm('Usunąć tę parę z listy?')) {
                            removePair(index);
                        }
                    };

                    itemDiv.appendChild(checkbox);
                    itemDiv.appendChild(nameDiv);
                    if (warningIcon) itemDiv.appendChild(warningIcon);
                    // itemDiv.appendChild(ocrStatus); - REMOVED
                    itemDiv.appendChild(removeBtn);
                    itemDiv.onclick = (e) => {
                        if (!e.target.closest('.checkbox') && !e.target.closest('.remove-pair-btn')) {
                            selectedUnpairedOldIndex = null;
                            selectedUnpairedNewIndex = null;
                            loadPair(index);
                        }
                    };
                    
                    filesDiv.appendChild(itemDiv);
                });

                groupDiv.appendChild(filesDiv);
                pairList.appendChild(groupDiv);
            });

            if (unpairedOld.length > 0) {
                const groupDiv = document.createElement('div');
                groupDiv.className = 'icao-group';

                let totalPages = unpairedOld.reduce((sum, item) => sum + item.totalPages, 0);
                const header = document.createElement('div');
                header.className = 'icao-header unpaired-old';
                header.innerHTML = `<span>🔴 OLD (${unpairedOld.length})</span><span class="arrow">▼</span>`;
                header.onclick = (e) => {
                    e.stopPropagation();
                    header.classList.toggle('collapsed');
                    filesDiv.classList.toggle('hidden');
                };
                groupDiv.appendChild(header);

                const filesDiv = document.createElement('div');
                filesDiv.className = 'icao-files';

                unpairedOld.forEach((item, itemIndex) => {
                    const itemDiv = document.createElement('div');
                    itemDiv.className = 'unpaired-item-sidebar';
                    itemDiv.style.display = 'flex';
                    itemDiv.style.alignItems = 'center';
                    itemDiv.style.justifyContent = 'space-between';
                    
                    if (selectedUnpairedOldIndex === itemIndex) {
                        itemDiv.classList.add('selected');
                    }
                    itemDiv.draggable = true;
                    
                    const nameSpan = document.createElement('span');
                    nameSpan.textContent = item.name;
                    nameSpan.style.flex = '1';
                    nameSpan.style.minWidth = '0';
                    nameSpan.style.overflow = 'hidden';
                    nameSpan.style.textOverflow = 'ellipsis';
                    nameSpan.style.whiteSpace = 'nowrap';
                    
                    const removeBtn = document.createElement('button');
                    removeBtn.textContent = '❌';
                    removeBtn.style.background = 'none';
                    removeBtn.style.border = 'none';
                    removeBtn.style.color = '#dc3545';
                    removeBtn.style.cursor = 'pointer';
                    removeBtn.style.fontSize = '0.9em';
                    removeBtn.style.padding = '2px 5px';
                    removeBtn.title = 'Usuń z listy';
                    removeBtn.onclick = (e) => {
                        e.stopPropagation();
                        unpairedOld.splice(itemIndex, 1);
                        renderPairList();
                    };
                    
                    itemDiv.appendChild(nameSpan);
                    itemDiv.appendChild(removeBtn);
                    
                    // Kliknięcie w pojedynczą mapę OLD
                    itemDiv.onclick = () => {
                        selectedUnpairedOldIndex = itemIndex;
                        selectedUnpairedOldPage = 0;
                        // NIE resetuj selectedUnpairedNewIndex - pozwól na porównanie
                        renderPairList();
                        renderUnpairedView();
                    };
                    
                    itemDiv.addEventListener('dragstart', (e) => {
                        e.dataTransfer.setData('text/plain', `unpaired-old-${itemIndex}`);
                        itemDiv.classList.add('dragging');
                    });
                    
                    itemDiv.addEventListener('dragend', () => {
                        itemDiv.classList.remove('dragging');
                    });
                    
                    filesDiv.appendChild(itemDiv);
                });

                groupDiv.appendChild(filesDiv);
                pairList.appendChild(groupDiv);
            }

            if (unpairedNew.length > 0) {
                const groupDiv = document.createElement('div');
                groupDiv.className = 'icao-group';

                let totalPages = unpairedNew.reduce((sum, item) => sum + item.totalPages, 0);
                const header = document.createElement('div');
                header.className = 'icao-header unpaired-new';
                header.innerHTML = `<span>🟢 NEW (${unpairedNew.length})</span><span class="arrow">▼</span>`;
                header.onclick = (e) => {
                    e.stopPropagation();
                    header.classList.toggle('collapsed');
                    filesDiv.classList.toggle('hidden');
                };
                groupDiv.appendChild(header);

                const filesDiv = document.createElement('div');
                filesDiv.className = 'icao-files';

                unpairedNew.forEach((item, itemIndex) => {
                    const itemDiv = document.createElement('div');
                    itemDiv.className = 'unpaired-item-sidebar';
                    itemDiv.style.display = 'flex';
                    itemDiv.style.alignItems = 'center';
                    itemDiv.style.justifyContent = 'space-between';
                    
                    if (selectedUnpairedNewIndex === itemIndex) {
                        itemDiv.classList.add('selected');
                    }
                    itemDiv.draggable = true;
                    
                    const nameSpan = document.createElement('span');
                    nameSpan.textContent = item.name;
                    nameSpan.style.flex = '1';
                    nameSpan.style.minWidth = '0';
                    nameSpan.style.overflow = 'hidden';
                    nameSpan.style.textOverflow = 'ellipsis';
                    nameSpan.style.whiteSpace = 'nowrap';
                    
                    const removeBtn = document.createElement('button');
                    removeBtn.textContent = '❌';
                    removeBtn.style.background = 'none';
                    removeBtn.style.border = 'none';
                    removeBtn.style.color = '#dc3545';
                    removeBtn.style.cursor = 'pointer';
                    removeBtn.style.fontSize = '0.9em';
                    removeBtn.style.padding = '2px 5px';
                    removeBtn.title = 'Usuń z listy';
                    removeBtn.onclick = (e) => {
                        e.stopPropagation();
                        unpairedNew.splice(itemIndex, 1);
                        renderPairList();
                    };
                    
                    itemDiv.appendChild(nameSpan);
                    itemDiv.appendChild(removeBtn);
                    
                    // Kliknięcie w pojedynczą mapę NEW
                    itemDiv.onclick = () => {
                        selectedUnpairedNewIndex = itemIndex;
                        selectedUnpairedNewPage = 0;
                        // NIE resetuj selectedUnpairedOldIndex - pozwól na porównanie
                        renderPairList();
                        renderUnpairedView();
                    };
                    
                    itemDiv.addEventListener('dragstart', (e) => {
                        e.dataTransfer.setData('text/plain', `unpaired-new-${itemIndex}`);
                        itemDiv.classList.add('dragging');
                    });
                    
                    itemDiv.addEventListener('dragend', () => {
                        itemDiv.classList.remove('dragging');
                    });
                    
                    filesDiv.appendChild(itemDiv);
                });

                groupDiv.appendChild(filesDiv);
                pairList.appendChild(groupDiv);
            }
        }

        function toggleCheckbox(index) {
            if (checkedPairs.has(index)) {
                checkedPairs.delete(index);
            } else {
                checkedPairs.add(index);
            }
            renderPairList();
            updateStats();
        }

        async function renderUnpairedView() {
            const viewer = document.getElementById('viewer');
            const label = document.getElementById('canvasLabel');
            const pageNav = document.getElementById('pageNav');
            
            // Wyczyść poprzedni widok
            viewer.innerHTML = '';
            pageNav.style.display = 'none';
            
            // Jeśli zaznaczono OBA (OLD i NEW) - utwórz porównanie
            if (selectedUnpairedOldIndex !== null && selectedUnpairedNewIndex !== null) {
                const oldItem = unpairedOld[selectedUnpairedOldIndex];
                const newItem = unpairedNew[selectedUnpairedNewIndex];
                
                if (!oldItem || !newItem) return;
                
                // Utwórz tymczasową parę do porównania
                const tempPair = {
                    name: `${oldItem.name} vs ${newItem.name}`,
                    oldFile: oldItem.file,
                    newFile: newItem.file,
                    oldDoc: oldItem.doc,
                    newDoc: newItem.doc,
                    totalPages: Math.max(oldItem.totalPages, newItem.totalPages),
                    icao: 'MANUAL'
                };
                
                const pageNum = Math.min(
                    (selectedUnpairedOldPage || 0) + 1,
                    (selectedUnpairedNewPage || 0) + 1
                );
                
                // Renderuj w zależności od trybu
                if (currentMode === 'toggle') {
                    await renderToggle(tempPair, pageNum);
                } else if (currentMode === 'overlay') {
                    await renderOverlay(tempPair, pageNum);
                } else if (currentMode === 'sidebyside') {
                    await renderSideBySide(tempPair, pageNum);
                }
                
                // Pokaż informację o nawigacji stron jeśli są multi-page
                if (tempPair.totalPages > 1) {
                    pageNav.style.display = 'flex';
                    document.getElementById('pageInfo').textContent = `Strona ${pageNum} z ${tempPair.totalPages}`;
                }
            }
            // Jeśli zaznaczono tylko OLD
            else if (selectedUnpairedOldIndex !== null) {
                const item = unpairedOld[selectedUnpairedOldIndex];
                if (!item) return;
                
                await renderSinglePDF(item, selectedUnpairedOldPage || 0, 'OLD', 'red');
                
                if (item.totalPages > 1) {
                    pageNav.style.display = 'flex';
                    document.getElementById('pageInfo').textContent = `Strona ${(selectedUnpairedOldPage || 0) + 1} z ${item.totalPages}`;
                }
            }
            // Jeśli zaznaczono tylko NEW
            else if (selectedUnpairedNewIndex !== null) {
                const item = unpairedNew[selectedUnpairedNewIndex];
                if (!item) return;
                
                await renderSinglePDF(item, selectedUnpairedNewPage || 0, 'NEW', 'green');
                
                if (item.totalPages > 1) {
                    pageNav.style.display = 'flex';
                    document.getElementById('pageInfo').textContent = `Strona ${(selectedUnpairedNewPage || 0) + 1} z ${item.totalPages}`;
                }
            }
        }

        async function renderSinglePDF(item, pageIndex, labelText, labelColor) {
            const viewer = document.getElementById('viewer');
            const label = document.getElementById('canvasLabel');
            
            const container = document.createElement('div');
            container.className = 'canvas-container';
            container.style.position = 'relative';
            
            const canvas = document.createElement('canvas');
            
            label.textContent = labelText;
            label.style.background = labelColor === 'red' ? 'rgba(220, 53, 69, 0.8)' : 'rgba(40, 167, 69, 0.8)';
            label.style.display = 'block';
            
            const scale = getRenderScale();
            const pageNum = pageIndex + 1;
            
            if (pageNum <= item.doc.numPages) {
                const page = await item.doc.getPage(pageNum);
                const viewport = page.getViewport({scale: scale});
                canvas.width = viewport.width;
                canvas.height = viewport.height;
                const ctx = canvas.getContext('2d');
                await page.render({canvasContext: ctx, viewport: viewport}).promise;
            }
            
            container.appendChild(canvas);
            viewer.appendChild(container);
            
            addZoomToCanvas(container);
        }

        function toggleCheckbox(index) {
            if (checkedPairs.has(index)) {
                checkedPairs.delete(index);
            } else {
                checkedPairs.add(index);
            }
            renderPairList();
            updateStats();
        }

        async function loadPair(index) {
            if (index < 0 || index >= pdfPairs.length) return;

            currentPairIndex = index;
            currentPageIndex = 0;
            checkedPairs.add(index);

            renderPairList();
            updateStats();

            const pair = pdfPairs[index];
            
            // Aktualizuj nazwę mapy w fullscreen
            const fullscreenMapName = document.getElementById('fullscreenMapName');
            if (fullscreenMapName && pair) {
                fullscreenMapName.textContent = pair.name || '';
            }
            
            const pageNav = document.getElementById('pageNav');
            if (pair.totalPages > 1) {
                pageNav.style.display = 'flex';
                updatePageInfo();
            } else {
                pageNav.style.display = 'none';
            }

            await renderCurrentPage();
        }

        async function renderCurrentPage() {
            const pair = pdfPairs[currentPairIndex];
            const pageNum = currentPageIndex + 1;
            const viewer = document.getElementById('viewer');
            viewer.innerHTML = '';
            viewer.style.display = '';

            document.getElementById('canvasLabel').style.display = 'block';
            document.getElementById('resetZoomBtn').style.display = 'block';
            document.getElementById('fullscreenToggleBtn').style.display = 'block';

            syncState = { zoom: 1, panX: 0, panY: 0 };
            currentRotation = 0;

            if (currentMode === 'toggle') {
                await renderToggle(pair, pageNum);
            } else if (currentMode === 'overlay') {
                await renderOverlay(pair, pageNum);
            } else {
                await renderSideBySide(pair, pageNum);
            }
            
            if (ocrMode) {
                await renderOCROverlay();
            }
        }

        async function renderToggle(pair, pageNum) {
            const viewer = document.getElementById('viewer');
            const label = document.getElementById('canvasLabel');
            
            const container = document.createElement('div');
            container.className = 'canvas-container';
            container.style.position = 'relative';
            container.id = 'toggleContainer';

            const oldCanvas = document.createElement('canvas');
            oldCanvas.id = 'toggleCanvasOld';
            
            const newCanvas = document.createElement('canvas');
            newCanvas.id = 'toggleCanvasNew';
            newCanvas.style.position = 'absolute';
            newCanvas.style.top = '0';
            newCanvas.style.left = '0';

            container.appendChild(oldCanvas);
            container.appendChild(newCanvas);
            viewer.appendChild(container);

            const scale = getRenderScale();
            
            // === JeppALLIGN v3.18: Render to temporary canvases first ===
            const tempOldCanvas = document.createElement('canvas');
            const tempNewCanvas = document.createElement('canvas');

            if (pageNum <= pair.oldDoc.numPages) {
                const page = await pair.oldDoc.getPage(pageNum);
                const viewport = page.getViewport({scale: scale});
                tempOldCanvas.width = viewport.width;
                tempOldCanvas.height = viewport.height;
                const ctx = tempOldCanvas.getContext('2d');
                await page.render({canvasContext: ctx, viewport: viewport}).promise;
            }

            if (pageNum <= pair.newDoc.numPages) {
                const page = await pair.newDoc.getPage(pageNum);
                const viewport = page.getViewport({scale: scale});
                tempNewCanvas.width = viewport.width;
                tempNewCanvas.height = viewport.height;
                const ctx = tempNewCanvas.getContext('2d');
                await page.render({canvasContext: ctx, viewport: viewport}).promise;
            }
            
            // === JeppALLIGN v3.18: Calculate max dimensions and apply alignment ===
            const alignment = alignmentOffsets.get(currentPairIndex);
            
            if (alignment && !manualAlignmentMode) {
                // Calculate transformed size for OLD canvas
                const oldTransformedW = tempOldCanvas.width * alignment.scaleX;
                const oldTransformedH = tempOldCanvas.height * alignment.scaleY;
                
                // Calculate maximum dimensions needed
                const maxWidth = Math.max(
                    tempNewCanvas.width,
                    Math.abs(alignment.offsetX) + oldTransformedW
                );
                const maxHeight = Math.max(
                    tempNewCanvas.height,
                    Math.abs(alignment.offsetY) + oldTransformedH
                );
                
                // === OLD CANVAS: Same size as max, with transformation applied ===
                oldCanvas.width = maxWidth;
                oldCanvas.height = maxHeight;
                const oldCtx = oldCanvas.getContext('2d');
                oldCtx.fillStyle = 'white';
                oldCtx.fillRect(0, 0, maxWidth, maxHeight);
                
                oldCtx.save();
                oldCtx.translate(alignment.offsetX, alignment.offsetY);
                oldCtx.scale(alignment.scaleX, alignment.scaleY);
                oldCtx.drawImage(tempOldCanvas, 0, 0);
                oldCtx.restore();
                
                // === NEW CANVAS: Same size as max, no transformation ===
                newCanvas.width = maxWidth;
                newCanvas.height = maxHeight;
                const newCtx = newCanvas.getContext('2d');
                newCtx.fillStyle = 'white';
                newCtx.fillRect(0, 0, maxWidth, maxHeight);
                newCtx.drawImage(tempNewCanvas, 0, 0);
                
                console.log('✅ Toggle render with JeppALLIGN v3.18 logic:', maxWidth, 'x', maxHeight);
            } else if (manualAlignmentTransform && manualAlignmentMode) {
                // Manual alignment mode
                oldCanvas.width = tempOldCanvas.width;
                oldCanvas.height = tempOldCanvas.height;
                oldCanvas.getContext('2d').drawImage(tempOldCanvas, 0, 0);
                
                newCanvas.width = tempNewCanvas.width;
                newCanvas.height = tempNewCanvas.height;
                newCanvas.getContext('2d').drawImage(tempNewCanvas, 0, 0);
                applyManualTransformToCanvas(newCanvas, manualAlignmentTransform);
            } else {
                // No alignment
                oldCanvas.width = tempOldCanvas.width;
                oldCanvas.height = tempOldCanvas.height;
                oldCanvas.getContext('2d').drawImage(tempOldCanvas, 0, 0);
                
                newCanvas.width = tempNewCanvas.width;
                newCanvas.height = tempNewCanvas.height;
                newCanvas.getContext('2d').drawImage(tempNewCanvas, 0, 0);
            }
            
            await renderPDFAnnotations(container, pair.oldDoc, pageNum, oldCanvas.width, oldCanvas.height);

            showingOld = true;
            updateToggleView();
            addZoomToCanvas(container);
        }

        function applyCanvasAlignmentFixed(canvas, alignment) {
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            const tempCtx = tempCanvas.getContext('2d');
            
            tempCtx.drawImage(canvas, 0, 0);
            
            const ctx = canvas.getContext('2d');
            
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.save();
            ctx.translate(alignment.offsetX, alignment.offsetY);
            ctx.scale(alignment.scaleX, alignment.scaleY);
            ctx.drawImage(tempCanvas, 0, 0);
            ctx.restore();
        }

        function applyManualTransformToCanvas(canvas, transform) {
            if (!transform) return;
            
            // Create temporary canvas with original content
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.drawImage(canvas, 0, 0);
            
            // Clear and apply transformation
            const ctx = canvas.getContext('2d');
            ctx.save();
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.setTransform(transform.a, transform.c, transform.b, transform.d, transform.e, transform.f);
            ctx.drawImage(tempCanvas, 0, 0);
            ctx.restore();
        }

        function updateToggleView() {
            const oldCanvas = document.getElementById('toggleCanvasOld');
            const newCanvas = document.getElementById('toggleCanvasNew');
            const label = document.getElementById('canvasLabel');
            
            if (!oldCanvas || !newCanvas || !label) return;

            if (viewMode === 'old' || (viewMode === 'auto' && showingOld)) {
                oldCanvas.style.visibility = 'visible';
                oldCanvas.style.opacity = '1';
                newCanvas.style.visibility = 'hidden';
                newCanvas.style.opacity = '0';
                label.textContent = 'OLD';
                label.style.background = 'rgba(220, 53, 69, 0.8)';
            } else {
                oldCanvas.style.visibility = 'hidden';
                oldCanvas.style.opacity = '0';
                newCanvas.style.visibility = 'visible';
                newCanvas.style.opacity = '1';
                label.textContent = 'NEW';
                label.style.background = 'rgba(40, 167, 69, 0.8)';
            }
        }

        async function renderOverlay(pair, pageNum) {
            const viewer = document.getElementById('viewer');
            const label = document.getElementById('canvasLabel');
            
            const container = document.createElement('div');
            container.className = 'canvas-container';
            container.style.position = 'relative';
            container.id = 'overlayContainer';

            const oldCanvas = document.createElement('canvas');
            const newCanvas = document.createElement('canvas');
            newCanvas.style.position = 'absolute';
            newCanvas.style.top = '0';
            newCanvas.style.left = '0';

            label.textContent = 'OLD (czerwony) + NEW (zielony)';
            label.style.background = 'rgba(0,0,0,0.8)';

            const scale = getRenderScale();
            
            // === JeppALLIGN v3.18: Render to temporary canvases first ===
            const tempOldCanvas = document.createElement('canvas');
            const tempNewCanvas = document.createElement('canvas');

            if (pageNum <= pair.oldDoc.numPages) {
                const page = await pair.oldDoc.getPage(pageNum);
                const viewport = page.getViewport({scale: scale});
                tempOldCanvas.width = viewport.width;
                tempOldCanvas.height = viewport.height;
                const ctx = tempOldCanvas.getContext('2d');
                await page.render({canvasContext: ctx, viewport: viewport}).promise;
            }

            if (pageNum <= pair.newDoc.numPages) {
                const page = await pair.newDoc.getPage(pageNum);
                const viewport = page.getViewport({scale: scale});
                tempNewCanvas.width = viewport.width;
                tempNewCanvas.height = viewport.height;
                const ctx = tempNewCanvas.getContext('2d');
                await page.render({canvasContext: ctx, viewport: viewport}).promise;
            }
            
            // === JeppALLIGN v3.18: Calculate max dimensions and apply alignment ===
            const alignment = alignmentOffsets.get(currentPairIndex);
            
            if (alignment && !manualAlignmentMode) {
                // Calculate transformed size for OLD canvas
                const oldTransformedW = tempOldCanvas.width * alignment.scaleX;
                const oldTransformedH = tempOldCanvas.height * alignment.scaleY;
                
                // Calculate maximum dimensions needed
                const maxWidth = Math.max(
                    tempNewCanvas.width,
                    Math.abs(alignment.offsetX) + oldTransformedW
                );
                const maxHeight = Math.max(
                    tempNewCanvas.height,
                    Math.abs(alignment.offsetY) + oldTransformedH
                );
                
                // === OLD CANVAS: Same size as max, with transformation applied ===
                oldCanvas.width = maxWidth;
                oldCanvas.height = maxHeight;
                const oldCtx = oldCanvas.getContext('2d');
                oldCtx.fillStyle = 'white';
                oldCtx.fillRect(0, 0, maxWidth, maxHeight);
                
                oldCtx.save();
                oldCtx.translate(alignment.offsetX, alignment.offsetY);
                oldCtx.scale(alignment.scaleX, alignment.scaleY);
                oldCtx.drawImage(tempOldCanvas, 0, 0);
                oldCtx.restore();
                
                // Apply red filter to OLD
                applyMonochromaticFilter(oldCtx, maxWidth, maxHeight, 'red');
                
                // === NEW CANVAS: Same size as max, no transformation ===
                newCanvas.width = maxWidth;
                newCanvas.height = maxHeight;
                const newCtx = newCanvas.getContext('2d');
                newCtx.fillStyle = 'white';
                newCtx.fillRect(0, 0, maxWidth, maxHeight);
                newCtx.drawImage(tempNewCanvas, 0, 0);
                
                // Apply green filter to NEW
                applyMonochromaticFilter(newCtx, maxWidth, maxHeight, 'green');
                
                newCanvas.style.opacity = document.getElementById('opacityRange').value / 100;
                
                console.log('✅ Overlay render with JeppALLIGN v3.18 logic:', maxWidth, 'x', maxHeight);
            } else if (manualAlignmentTransform && manualAlignmentMode) {
                // Manual alignment mode
                oldCanvas.width = tempOldCanvas.width;
                oldCanvas.height = tempOldCanvas.height;
                const oldCtx = oldCanvas.getContext('2d');
                oldCtx.drawImage(tempOldCanvas, 0, 0);
                applyMonochromaticFilter(oldCtx, oldCanvas.width, oldCanvas.height, 'red');
                
                newCanvas.width = tempNewCanvas.width;
                newCanvas.height = tempNewCanvas.height;
                const newCtx = newCanvas.getContext('2d');
                newCtx.drawImage(tempNewCanvas, 0, 0);
                applyManualTransformToCanvas(newCanvas, manualAlignmentTransform);
                applyMonochromaticFilter(newCtx, newCanvas.width, newCanvas.height, 'green');
                newCanvas.style.opacity = document.getElementById('opacityRange').value / 100;
            } else {
                // No alignment
                oldCanvas.width = tempOldCanvas.width;
                oldCanvas.height = tempOldCanvas.height;
                const oldCtx = oldCanvas.getContext('2d');
                oldCtx.drawImage(tempOldCanvas, 0, 0);
                applyMonochromaticFilter(oldCtx, oldCanvas.width, oldCanvas.height, 'red');
                
                newCanvas.width = tempNewCanvas.width;
                newCanvas.height = tempNewCanvas.height;
                const newCtx = newCanvas.getContext('2d');
                newCtx.drawImage(tempNewCanvas, 0, 0);
                applyMonochromaticFilter(newCtx, newCanvas.width, newCanvas.height, 'green');
                newCanvas.style.opacity = document.getElementById('opacityRange').value / 100;
            }

            container.appendChild(oldCanvas);
            container.appendChild(newCanvas);
            viewer.appendChild(container);

            addZoomToCanvas(container);
        }

        function applyMonochromaticFilter(ctx, width, height, color) {
            const imageData = ctx.getImageData(0, 0, width, height);
            const data = imageData.data;
            
            const whiteThreshold = 245; // Tylko bardzo białe piksele pozostają białe
            
            for (let i = 0; i < data.length; i += 4) {
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                
                // Średnia jako luminancja
                const luminance = 0.299 * r + 0.587 * g + 0.114 * b;
                
                // Jeśli bardzo jasne (prawie białe) - zostaw białe
                if (luminance > whiteThreshold) {
                    data[i] = 255;
                    data[i + 1] = 255;
                    data[i + 2] = 255;
                } else {
                    // WSZYSTKIE inne kolory (także czarne) zamieniamy na czerwone/zielone
                    // Odwracamy intensywność: ciemne -> jasne kolory, jasne -> ciemne kolory
                    const invertedIntensity = 1 - (luminance / 255);
                    const colorValue = Math.floor(255 * Math.max(0.3, invertedIntensity)); // Min 30% jasności
                    
                    if (color === 'red') {
                        data[i] = colorValue;
                        data[i + 1] = 0;
                        data[i + 2] = 0;
                    } else {
                        data[i] = 0;
                        data[i + 1] = colorValue;
                        data[i + 2] = 0;
                    }
                }
            }
            
            ctx.putImageData(imageData, 0, 0);
        }

        async function renderSideBySide(pair, pageNum) {
            const viewer = document.getElementById('viewer');
            const label = document.getElementById('canvasLabel');
            
            label.style.display = 'none';
            
            const sidebyContainer = document.createElement('div');
            sidebyContainer.className = 'sidebyside-container';
            sidebyContainer.id = 'sidebyContainer';

            const scale = getRenderScale();

            const leftViewer = document.createElement('div');
            leftViewer.className = 'sidebyside-viewer';
            leftViewer.id = 'leftViewer';
            
            const oldLabel = document.createElement('div');
            oldLabel.className = 'sidebyside-label old';
            oldLabel.textContent = 'OLD';
            leftViewer.appendChild(oldLabel);
            
            // === JeppALLIGN v3.18: Render OLD with transformation ===
            if (pageNum <= pair.oldDoc.numPages) {
                const containerOld = document.createElement('div');
                containerOld.className = 'canvas-container';
                containerOld.id = 'oldContainer';
                
                // Render to temporary canvas first
                const tempCanvas = document.createElement('canvas');
                const page = await pair.oldDoc.getPage(pageNum);
                const viewport = page.getViewport({scale: scale});
                tempCanvas.width = viewport.width;
                tempCanvas.height = viewport.height;
                const tempCtx = tempCanvas.getContext('2d');
                await page.render({canvasContext: tempCtx, viewport: viewport}).promise;
                
                // Apply alignment transformation to OLD canvas
                const canvas = document.createElement('canvas');
                const alignment = alignmentOffsets.get(currentPairIndex);
                
                if (alignment) {
                    const oldTransformedW = tempCanvas.width * alignment.scaleX;
                    const oldTransformedH = tempCanvas.height * alignment.scaleY;
                    const maxWidth = Math.max(tempCanvas.width, Math.abs(alignment.offsetX) + oldTransformedW);
                    const maxHeight = Math.max(tempCanvas.height, Math.abs(alignment.offsetY) + oldTransformedH);
                    
                    canvas.width = maxWidth;
                    canvas.height = maxHeight;
                    const ctx = canvas.getContext('2d');
                    ctx.fillStyle = 'white';
                    ctx.fillRect(0, 0, maxWidth, maxHeight);
                    
                    ctx.save();
                    ctx.translate(alignment.offsetX, alignment.offsetY);
                    ctx.scale(alignment.scaleX, alignment.scaleY);
                    ctx.drawImage(tempCanvas, 0, 0);
                    ctx.restore();
                } else {
                    canvas.width = tempCanvas.width;
                    canvas.height = tempCanvas.height;
                    canvas.getContext('2d').drawImage(tempCanvas, 0, 0);
                }
                
                containerOld.appendChild(canvas);
                
                await renderPDFAnnotations(containerOld, pair.oldDoc, pageNum, canvas.width, canvas.height);
                
                leftViewer.appendChild(containerOld);
            }
            
            const rightViewer = document.createElement('div');
            rightViewer.className = 'sidebyside-viewer';
            rightViewer.id = 'rightViewer';
            
            const newLabel = document.createElement('div');
            newLabel.className = 'sidebyside-label new';
            newLabel.textContent = 'NEW';
            rightViewer.appendChild(newLabel);
            
            // === NEW canvas remains unchanged ===
            if (pageNum <= pair.newDoc.numPages) {
                const containerNew = document.createElement('div');
                containerNew.className = 'canvas-container';
                containerNew.id = 'newContainer';
                
                const canvas = document.createElement('canvas');
                const page = await pair.newDoc.getPage(pageNum);
                const viewport = page.getViewport({scale: scale});
                canvas.width = viewport.width;
                canvas.height = viewport.height;
                const ctx = canvas.getContext('2d');
                await page.render({canvasContext: ctx, viewport: viewport}).promise;
                
                containerNew.appendChild(canvas);
                
                await renderPDFAnnotations(containerNew, pair.newDoc, pageNum, canvas.width, canvas.height);
                
                rightViewer.appendChild(containerNew);
            }

            sidebyContainer.appendChild(leftViewer);
            sidebyContainer.appendChild(rightViewer);
            viewer.appendChild(sidebyContainer);
            
            addSyncedZoomSideBySide();
        }

        function addSyncedZoomSideBySide() {
            const oldContainer = document.getElementById('oldContainer');
            const newContainer = document.getElementById('newContainer');
            const leftViewer = document.getElementById('leftViewer');
            const rightViewer = document.getElementById('rightViewer');
            const resetBtn = document.getElementById('resetZoomBtn');
            const exitBtn = document.getElementById('exitFullscreenBtn');

            if (!oldContainer || !newContainer) return;

            let isPanning = false;
            let startX = 0, startY = 0;
            let activeViewer = null;

            resetBtn.onclick = () => {
                syncState = { zoom: 1, panX: 0, panY: 0 };
                currentRotation = 0;
                updateSyncTransform();
            };

            exitBtn.onclick = () => {
                if (document.fullscreenElement) {
                    document.exitFullscreen();
                }
            };

            const handleWheel = (e, targetViewer) => {
                e.preventDefault();
                
                const rect = targetViewer.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                const pointX = (x - targetViewer.scrollLeft) / syncState.zoom - syncState.panX;
                const pointY = (y - targetViewer.scrollTop) / syncState.zoom - syncState.panY;
                
                const delta = e.deltaY > 0 ? -0.1 : 0.1;
                syncState.zoom = Math.max(0.3, Math.min(5, syncState.zoom + delta));
                
                syncState.panX = (x - targetViewer.scrollLeft) / syncState.zoom - pointX;
                syncState.panY = (y - targetViewer.scrollTop) / syncState.zoom - pointY;
                
                updateSyncTransform();
            };

            const handleMouseDown = (e, viewer) => {
                isPanning = true;
                startX = e.clientX;
                startY = e.clientY;
                activeViewer = viewer;
                oldContainer.style.cursor = 'grabbing';
                newContainer.style.cursor = 'grabbing';
                e.preventDefault();
            };

            const handleMouseMove = (e) => {
                if (!isPanning) return;
                
                let dx = (e.clientX - startX) / syncState.zoom;
                let dy = (e.clientY - startY) / syncState.zoom;
                
                const radians = (currentRotation * Math.PI) / 180;
                const cos = Math.cos(-radians);
                const sin = Math.sin(-radians);
                const rotatedDx = dx * cos - dy * sin;
                const rotatedDy = dx * sin + dy * cos;
                
                const oldRect = oldContainer.getBoundingClientRect();
                const viewerRect = activeViewer.getBoundingClientRect();
                const mapFitsHorizontally = (oldRect.width * syncState.zoom) <= viewerRect.width;
                
                if (!mapFitsHorizontally) {
                    syncState.panX += rotatedDx;
                }
                syncState.panY += rotatedDy;
                
                updateSyncTransform();
                
                startX = e.clientX;
                startY = e.clientY;
            };

            const handleMouseUp = () => {
                if (isPanning) {
                    isPanning = false;
                    oldContainer.style.cursor = 'grab';
                    newContainer.style.cursor = 'grab';
                }
            };

            leftViewer.addEventListener('wheel', (e) => handleWheel(e, leftViewer));
            rightViewer.addEventListener('wheel', (e) => handleWheel(e, rightViewer));
            leftViewer.addEventListener('mousedown', (e) => handleMouseDown(e, leftViewer));
            rightViewer.addEventListener('mousedown', (e) => handleMouseDown(e, rightViewer));
            document.addEventListener('mousemove', handleMouseMove);
            document.addEventListener('mouseup', handleMouseUp);

            oldContainer.style.cursor = 'grab';
            newContainer.style.cursor = 'grab';

            updateSyncTransform();
        }

        function updateSyncTransform() {
            const oldContainer = document.getElementById('oldContainer');
            const newContainer = document.getElementById('newContainer');
            
            if (oldContainer && newContainer) {
                const transform = `rotate(${currentRotation}deg) scale(${syncState.zoom}) translate(${syncState.panX}px, ${syncState.panY}px)`;
                oldContainer.style.transform = transform;
                newContainer.style.transform = transform;
                oldContainer.style.transformOrigin = 'center center';
                newContainer.style.transformOrigin = 'center center';
            }
        }

        function addZoomToCanvas(container) {
            let zoom = 1;
            let isPanning = false;
            let startX = 0, startY = 0;
            let panX = 0, panY = 0;
            let rafId = null; // requestAnimationFrame ID
            let pendingTransform = false;

            const wrapper = document.getElementById('viewerWrapper');
            const resetBtn = document.getElementById('resetZoomBtn');
            const exitBtn = document.getElementById('exitFullscreenBtn');

            const applyTransform = () => {
                container.style.transform = `rotate(${currentRotation}deg) scale(${zoom}) translate(${panX}px, ${panY}px)`;
                container.style.transformOrigin = 'center center';
                container.style.willChange = 'transform'; // GPU acceleration hint
                pendingTransform = false;
            };
            
            // Throttled version using requestAnimationFrame
            const scheduleTransform = () => {
                if (!pendingTransform) {
                    pendingTransform = true;
                    rafId = requestAnimationFrame(applyTransform);
                }
            };

            resetBtn.onclick = () => {
                zoom = 1;
                panX = 0;
                panY = 0;
                currentRotation = 0;
                applyTransform();
            };

            exitBtn.onclick = () => {
                if (document.fullscreenElement) {
                    document.exitFullscreen();
                }
            };

            container.addEventListener('wheel', (e) => {
                e.preventDefault();
                
                const delta = e.deltaY > 0 ? -0.1 : 0.1;
                const newZoom = Math.max(0.3, Math.min(15, zoom + delta));
                
                zoom = newZoom;
                
                scheduleTransform(); // Use throttled version
            });

            container.addEventListener('mousedown', (e) => {
                isPanning = true;
                startX = e.clientX;
                startY = e.clientY;
                container.style.cursor = 'grabbing';
                e.preventDefault();
            });

            document.addEventListener('mousemove', (e) => {
                if (!isPanning) return;
                
                let dx = (e.clientX - startX) / zoom;
                let dy = (e.clientY - startY) / zoom;
                
                const radians = (currentRotation * Math.PI) / 180;
                const cos = Math.cos(-radians);
                const sin = Math.sin(-radians);
                const rotatedDx = dx * cos - dy * sin;
                const rotatedDy = dx * sin + dy * cos;
                
                panX += rotatedDx;
                panY += rotatedDy;
                
                scheduleTransform(); // Use throttled version instead of immediate
                
                startX = e.clientX;
                startY = e.clientY;
            });

            document.addEventListener('mouseup', () => {
                if (isPanning) {
                    isPanning = false;
                    container.style.cursor = 'grab';
                    // Clean up will-change after animation stops
                    setTimeout(() => {
                        container.style.willChange = 'auto';
                    }, 500);
                }
            });

            container.style.cursor = 'grab';
            applyTransform();
        }

        function toggleAutoMode() {
            const autoBtn = document.getElementById('autoBtn');
            const oldBtn = document.getElementById('oldBtn');
            const newBtn = document.getElementById('newBtn');
            
            if (viewMode === 'auto' && autoToggleInterval) {
                clearInterval(autoToggleInterval);
                autoToggleInterval = null;
                viewMode = 'old';
                autoBtn.classList.remove('active');
                autoBtn.textContent = '▶️ Auto';
                oldBtn.classList.add('active-old');
                newBtn.classList.remove('active-new');
                showingOld = true;
                updateToggleView();
            } else {
                viewMode = 'auto';
                const speed = parseInt(document.getElementById('speedRange').value);
                autoToggleInterval = setInterval(() => {
                    if (currentMode === 'toggle') {
                        showingOld = !showingOld;
                        updateToggleView();
                    }
                }, speed);
                autoBtn.classList.add('active');
                autoBtn.textContent = '⏸ Auto';
                oldBtn.classList.remove('active-old');
                newBtn.classList.remove('active-new');
            }
        }

        function showOldOnly() {
            if (autoToggleInterval) {
                clearInterval(autoToggleInterval);
                autoToggleInterval = null;
            }
            
            viewMode = 'old';
            showingOld = true;
            
            const autoBtn = document.getElementById('autoBtn');
            const oldBtn = document.getElementById('oldBtn');
            const newBtn = document.getElementById('newBtn');
            
            autoBtn.classList.remove('active');
            autoBtn.textContent = '▶️ Auto';
            oldBtn.classList.add('active-old');
            newBtn.classList.remove('active-new');
            
            updateToggleView();
        }

        function showNewOnly() {
            if (autoToggleInterval) {
                clearInterval(autoToggleInterval);
                autoToggleInterval = null;
            }
            
            viewMode = 'new';
            showingOld = false;
            
            const autoBtn = document.getElementById('autoBtn');
            const oldBtn = document.getElementById('oldBtn');
            const newBtn = document.getElementById('newBtn');
            
            autoBtn.classList.remove('active');
            autoBtn.textContent = '▶️ Auto';
            oldBtn.classList.remove('active-old');
            newBtn.classList.add('active-new');
            
            updateToggleView();
        }

        function setMode(mode) {
            // Handle manual alignment mode
            if (mode === 'manual') {
                if (!manualAlignmentMode) {
                    startManualAlignment();
                }
                return;
            }
            
            // Exit manual alignment mode if switching to another mode
            if (manualAlignmentMode) {
                exitManualAlignment();
            }
            
            currentMode = mode;
            document.querySelectorAll('.mode-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            
            if (selectedUnpairedOldIndex !== null || selectedUnpairedNewIndex !== null) {
                renderUnpairedView();
            } else {
                renderCurrentPage();
            }
        }

        function prevPage() {
            if (currentPageIndex > 0) {
                currentPageIndex--;
                updatePageInfo();
                renderCurrentPage();
            }
        }

        function nextPage() {
            const pair = pdfPairs[currentPairIndex];
            if (currentPageIndex < pair.totalPages - 1) {
                currentPageIndex++;
                updatePageInfo();
                renderCurrentPage();
            }
        }

        function updatePageInfo() {
            const pair = pdfPairs[currentPairIndex];
            document.getElementById('pageInfo').textContent = `Strona ${currentPageIndex + 1} z ${pair.totalPages}`;
            document.querySelector('.page-nav button:first-child').disabled = currentPageIndex === 0;
            document.querySelector('.page-nav button:last-child').disabled = currentPageIndex === pair.totalPages - 1;
        }

        function updateStats() {
            // Stats box został zastąpiony przez JAD Generator
            // Aktualizujemy kod JAD zamiast statystyk
            updateJADCode();
        }

        function rotateMap(degrees) {
            currentRotation = (currentRotation + degrees) % 360;
            if (currentRotation < 0) currentRotation += 360;
            
            if (currentMode === 'sidebyside') {
                updateSyncTransform();
            } else {
                const containers = document.querySelectorAll('.canvas-container');
                containers.forEach(container => {
                    const style = window.getComputedStyle(container);
                    const matrix = style.transform;
                    
                    if (matrix && matrix !== 'none') {
                        const currentTransform = container.style.transform;
                        if (currentTransform.includes('scale')) {
                            const scaleMatch = currentTransform.match(/scale\(([\d.]+)\)/);
                            const translateMatch = currentTransform.match(/translate\(([-\d.]+)px,\s*([-\d.]+)px\)/);
                            
                            if (scaleMatch && translateMatch) {
                                const scale = scaleMatch[1];
                                const tx = translateMatch[1];
                                const ty = translateMatch[2];
                                container.style.transform = `rotate(${currentRotation}deg) scale(${scale}) translate(${tx}px, ${ty}px)`;
                            } else {
                                container.style.transform = `rotate(${currentRotation}deg)`;
                            }
                        } else {
                            container.style.transform = `rotate(${currentRotation}deg)`;
                        }
                    } else {
                        container.style.transform = `rotate(${currentRotation}deg)`;
                    }
                    container.style.transformOrigin = 'center center';
                });
            }
            
            if (ocrMode) {
                renderOCROverlay();
            }
        }

        function toggleFullscreen() {
            const elem = document.getElementById('viewerWrapper');
            const fullscreenToggleBtn = document.getElementById('fullscreenToggleBtn');
            const exitBtn = document.getElementById('exitFullscreenBtn');
            
            if (!document.fullscreenElement) {
                elem.requestFullscreen();
                if (fullscreenToggleBtn) fullscreenToggleBtn.style.display = 'none';
                if (exitBtn) exitBtn.style.display = 'block';
            } else {
                document.exitFullscreen();
                if (fullscreenToggleBtn) fullscreenToggleBtn.style.display = 'block';
                if (exitBtn) exitBtn.style.display = 'none';
            }
        }
        
        // Listener do zmiany fullscreen
        document.addEventListener('fullscreenchange', () => {
            const fullscreenToggleBtn = document.getElementById('fullscreenToggleBtn');
            const exitBtn = document.getElementById('exitFullscreenBtn');
            
            if (document.fullscreenElement) {
                if (fullscreenToggleBtn) fullscreenToggleBtn.style.display = 'none';
                if (exitBtn) exitBtn.style.display = 'block';
            } else {
                if (fullscreenToggleBtn) fullscreenToggleBtn.style.display = 'block';
                if (exitBtn) exitBtn.style.display = 'none';
            }
        });

        // FIX #3b: COMPLETE session isolation when clicking "Nowe"
        function resetAndUpload() {
            if (autoToggleInterval) clearInterval(autoToggleInterval);
            
            // Clear ALL annotation popups from document.body
            document.querySelectorAll('.pdf-annotation-popup').forEach(el => el.remove());
            
            pdfPairs = [];
            unpairedOld = [];
            unpairedNew = [];
            currentPairIndex = 0;
            currentPageIndex = 0;
            checkedPairs.clear();
            oldFiles = [];
            newFiles = [];
            syncState = { zoom: 1, panX: 0, panY: 0 };
            viewMode = 'auto';
            selectedUnpairedOldIndex = null;
            selectedUnpairedOldPage = null;
            selectedUnpairedNewIndex = null;
            selectedUnpairedNewPage = null;
            ocrMode = null;
            ocrResults.clear();
            manualPairingOldFiles = [];
            manualPairingNewFiles = [];
            alignmentOffsets.clear();
            pdfAnnotations.clear();
            
            // Reset quality to standard
            renderQuality = 'standard';
            selectQuality('standard');
            
            document.getElementById('comparisonSection').style.display = 'none';
            document.getElementById('uploadSection').style.display = 'block';
            document.getElementById('compareButtonContainer').style.display = 'none';
            oldFileInput.value = '';
            newFileInput.value = '';
            updateFileInfo();
        }

        document.getElementById('speedRange').addEventListener('input', (e) => {
            const value = e.target.value;
            document.getElementById('speedValue').textContent = (value / 1000).toFixed(1) + 's';
            if (autoToggleInterval) {
                clearInterval(autoToggleInterval);
                const speed = parseInt(value);
                autoToggleInterval = setInterval(() => {
                    if (currentMode === 'toggle') {
                        showingOld = !showingOld;
                        updateToggleView();
                    }
                }, speed);
            }
        });

        document.getElementById('sensitivityRange').addEventListener('input', (e) => {
            const value = e.target.value;
            document.getElementById('sensitivityValue').textContent = value + '%';
            if (ocrMode === 'hybrid') {
                renderOCROverlay();
            }
        });

        document.getElementById('opacityRange').addEventListener('input', (e) => {
            const value = e.target.value;
            document.getElementById('opacityValue').textContent = value + '%';
            if (currentMode === 'overlay') {
                const newCanvas = document.querySelector('#overlayContainer canvas:last-of-type');
                if (newCanvas) newCanvas.style.opacity = value / 100;
            }
        });

        // Zamykanie popupów adnotacji kliknięciem w tło
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.pdf-annotation') && !e.target.closest('.pdf-annotation-popup')) {
                document.querySelectorAll('.pdf-annotation-popup').forEach(popup => {
                    popup.style.display = 'none';
                });
            }
        });

        document.addEventListener('keydown', (e) => {
            if (pdfPairs.length === 0) return;
            
            const isFullscreen = document.fullscreenElement !== null;
            
            // W trybie fullscreen - dodatkowe skróty
            if (isFullscreen) {
                if (e.key === 'Control' || e.key === 'Ctrl') {
                    e.preventDefault();
                    // Zatrzymaj auto-toggle
                    if (autoToggleInterval) {
                        clearInterval(autoToggleInterval);
                        autoToggleInterval = null;
                        viewMode = 'manual';
                        const autoBtn = document.getElementById('autoBtn');
                        if (autoBtn) {
                            autoBtn.classList.remove('active');
                            autoBtn.textContent = '▶️ Auto';
                        }
                    }
                    // Przełącz OLD/NEW
                    if (currentMode === 'toggle') {
                        showingOld = !showingOld;
                        updateToggleView();
                    }
                    return;
                }
                
                if (e.key === 'p' || e.key === 'P') {
                    e.preventDefault();
                    toggleOCRMode('hybrid');
                    return;
                }
            }
            
            // Standardowe skróty (działają zawsze)
            switch(e.key) {
                case 'ArrowLeft': 
                    e.preventDefault();
                    prevPage(); 
                    break;
                case 'ArrowRight': 
                    e.preventDefault();
                    nextPage(); 
                    break;
                case 'ArrowUp': 
                    e.preventDefault();
                    if (currentPairIndex > 0) loadPair(currentPairIndex - 1); 
                    break;
                case 'ArrowDown': 
                    e.preventDefault();
                    if (currentPairIndex < pdfPairs.length - 1) loadPair(currentPairIndex + 1); 
                    break;
                case ' ': 
                    e.preventDefault(); 
                    toggleAutoMode(); 
                    break;
                case '1': 
                    setMode('toggle'); 
                    break;
                case '2': 
                    setMode('overlay'); 
                    break;
                case '3': 
                    setMode('sidebyside'); 
                    break;
            }
        });

        // RESIZABLE SIDEBARS - sprzężone rozmiary
        function initResizers() {
            const leftSidebar = document.getElementById('leftSidebar');
            const rightSidebar = document.getElementById('rightSidebar');
            const mainContent = document.getElementById('mainContent');
            const leftResizer = document.getElementById('leftResizer');
            const rightResizer = document.getElementById('rightResizer');
            
            let isResizingLeft = false;
            let isResizingRight = false;
            let startX = 0;
            let startLeftWidth = 0;
            let startRightWidth = 0;
            
            // Left resizer
            leftResizer.addEventListener('mousedown', (e) => {
                isResizingLeft = true;
                startX = e.clientX;
                startLeftWidth = leftSidebar.offsetWidth;
                document.body.style.cursor = 'col-resize';
                e.preventDefault();
            });
            
            // Right resizer
            rightResizer.addEventListener('mousedown', (e) => {
                isResizingRight = true;
                startX = e.clientX;
                startRightWidth = rightSidebar.offsetWidth;
                document.body.style.cursor = 'col-resize';
                e.preventDefault();
            });
            
            document.addEventListener('mousemove', (e) => {
                if (isResizingLeft) {
                    const delta = e.clientX - startX;
                    const newLeftWidth = Math.max(200, Math.min(800, startLeftWidth + delta));
                    leftSidebar.style.width = newLeftWidth + 'px';
                } else if (isResizingRight) {
                    const delta = startX - e.clientX; // Odwrotnie dla prawego
                    const newRightWidth = Math.max(150, Math.min(500, startRightWidth + delta));
                    rightSidebar.style.width = newRightWidth + 'px';
                }
            });
            
            document.addEventListener('mouseup', () => {
                if (isResizingLeft || isResizingRight) {
                    isResizingLeft = false;
                    isResizingRight = false;
                    document.body.style.cursor = 'default';
                }
            });
        }
        
        // Inicjalizuj resizery po załadowaniu
        document.addEventListener('DOMContentLoaded', () => {
            initResizers();
        });
        
        // Dla pewności wywołaj też od razu
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initResizers);
        } else {
            initResizers();
        }
        
        // ===== MANUAL ALIGNMENT FUNCTIONS =====
        
        function startManualAlignment() {
            manualAlignmentMode = true;
            manualAlignmentOriginalMode = currentMode;
            manualAlignmentStep = 'map1';
            manualAlignmentPoints1 = [];
            manualAlignmentPoints2 = [];
            manualAlignmentTransform = null;
            
            // Show manual controls
            document.getElementById('manualAlignControls').style.display = 'block';
            
            // Activate manual mode button
            document.querySelectorAll('.mode-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelectorAll('.mode-btn').forEach(btn => {
                if (btn.textContent.includes('Ręczne')) {
                    btn.classList.add('active');
                }
            });
            
            // Render in toggle mode to show first map
            currentMode = 'toggle';
            viewMode = 'old';
            showingOld = true;
            
            renderCurrentPage().then(() => {
                // Add click handler to canvas
                addManualAlignmentClickHandler();
                showManualAlignmentStatus('Kliknij 4 punkty na mapie OLD (punkt 1/4)');
            });
        }
        
        function exitManualAlignment() {
            manualAlignmentMode = false;
            removeManualAlignmentClickHandler();
            clearManualAlignmentPoints();
            hideManualAlignmentStatus();
            
            // Hide manual controls
            document.getElementById('manualAlignControls').style.display = 'none';
            
            // Restore original mode
            if (manualAlignmentOriginalMode) {
                currentMode = manualAlignmentOriginalMode;
            }
        }
        
        function resetManualAlignment() {
            if (manualAlignmentTransform) {
                manualAlignmentTransform = null;
                manualAlignmentPoints1 = [];
                manualAlignmentPoints2 = [];
                manualAlignmentStep = 'map1';
                
                // Re-render current page without transformation
                currentMode = 'toggle';
                viewMode = 'old';
                showingOld = true;
                
                renderCurrentPage().then(() => {
                    addManualAlignmentClickHandler();
                    showManualAlignmentStatus('Reset ukończony. Kliknij 4 punkty na mapie OLD (punkt 1/4)');
                });
            }
        }
        
        function addManualAlignmentClickHandler() {
            const viewer = document.getElementById('viewer');
            if (!viewer) return;
            
            // Add crosshair cursor
            const containers = viewer.querySelectorAll('.canvas-container');
            containers.forEach(container => {
                container.classList.add('manual-align-mode');
            });
            
            // Remove existing handler
            viewer.removeEventListener('click', handleManualAlignmentClick);
            // Add new handler
            viewer.addEventListener('click', handleManualAlignmentClick);
        }
        
        function removeManualAlignmentClickHandler() {
            const viewer = document.getElementById('viewer');
            if (!viewer) return;
            
            viewer.removeEventListener('click', handleManualAlignmentClick);
            
            const containers = viewer.querySelectorAll('.canvas-container');
            containers.forEach(container => {
                container.classList.remove('manual-align-mode');
            });
        }
        
        async function handleManualAlignmentClick(e) {
            if (!manualAlignmentMode) return;
            
            const viewer = document.getElementById('viewer');
            const container = viewer.querySelector('.canvas-container');
            const canvas = container.querySelector('canvas');
            if (!canvas) return;
            
            // Get click coordinates relative to canvas
            const rect = canvas.getBoundingClientRect();
            const canvasX = e.clientX - rect.left;
            const canvasY = e.clientY - rect.top;
            
            // Convert to PDF coordinates (accounting for zoom and pan)
            const transform = window.getComputedStyle(container).transform;
            let scale = 1;
            if (transform && transform !== 'none') {
                const matrix = transform.match(/matrix\(([^)]+)\)/);
                if (matrix) {
                    const values = matrix[1].split(',').map(parseFloat);
                    scale = values[0]; // a value in matrix
                }
            }
            
            const pdfX = canvasX / scale;
            const pdfY = canvasY / scale;
            
            if (manualAlignmentStep === 'map1') {
                manualAlignmentPoints1.push({ x: pdfX, y: pdfY });
                
                // Draw point marker
                drawManualAlignmentPoint(container, canvasX, canvasY, manualAlignmentPoints1.length);
                
                if (manualAlignmentPoints1.length < 4) {
                    showManualAlignmentStatus(`Kliknij punkt ${manualAlignmentPoints1.length + 1}/4 na mapie OLD`);
                } else {
                    // Switch to map 2
                    manualAlignmentStep = 'map2';
                    showManualAlignmentStatus('Punkty na OLD zaznaczone! Przełączanie na NEW...');
                    
                    // Clear points display
                    clearManualAlignmentPoints();
                    
                    // Switch to NEW map
                    viewMode = 'new';
                    showingOld = false;
                    
                    setTimeout(async () => {
                        await renderCurrentPage();
                        addManualAlignmentClickHandler();
                        showManualAlignmentStatus('Kliknij 4 punkty na mapie NEW (punkt 1/4)');
                    }, 500);
                }
            } else if (manualAlignmentStep === 'map2') {
                manualAlignmentPoints2.push({ x: pdfX, y: pdfY });
                
                // Draw point marker
                drawManualAlignmentPoint(container, canvasX, canvasY, manualAlignmentPoints2.length);
                
                if (manualAlignmentPoints2.length < 4) {
                    showManualAlignmentStatus(`Kliknij punkt ${manualAlignmentPoints2.length + 1}/4 na mapie NEW`);
                } else {
                    // Calculate transformation and apply
                    showManualAlignmentStatus('Obliczanie transformacji...');
                    calculateManualAlignmentTransform();
                    
                    setTimeout(() => {
                        applyManualAlignmentAndRender();
                    }, 500);
                }
            }
        }
        
        function drawManualAlignmentPoint(container, x, y, number) {
            const point = document.createElement('div');
            point.className = 'manual-align-point';
            point.style.left = x + 'px';
            point.style.top = y + 'px';
            
            const label = document.createElement('div');
            label.className = 'manual-align-label';
            label.textContent = number;
            label.style.left = x + 'px';
            label.style.top = y + 'px';
            
            container.appendChild(point);
            container.appendChild(label);
        }
        
        function clearManualAlignmentPoints() {
            const viewer = document.getElementById('viewer');
            if (!viewer) return;
            
            viewer.querySelectorAll('.manual-align-point, .manual-align-label').forEach(el => el.remove());
        }
        
        function showManualAlignmentStatus(message) {
            let status = document.querySelector('.manual-align-status');
            if (!status) {
                status = document.createElement('div');
                status.className = 'manual-align-status';
                document.getElementById('viewer').appendChild(status);
            }
            status.textContent = message;
            status.style.display = 'block';
        }
        
        function hideManualAlignmentStatus() {
            const status = document.querySelector('.manual-align-status');
            if (status) {
                status.remove();
            }
        }
        
        function calculateManualAlignmentTransform() {
            // Calculate affine transformation using first 3 points
            const src = manualAlignmentPoints2.slice(0, 3);
            const dst = manualAlignmentPoints1.slice(0, 3);
            
            const x1 = src[0].x, y1 = src[0].y;
            const x2 = src[1].x, y2 = src[1].y;
            const x3 = src[2].x, y3 = src[2].y;
            
            const u1 = dst[0].x, v1 = dst[0].y;
            const u2 = dst[1].x, v2 = dst[1].y;
            const u3 = dst[2].x, v3 = dst[2].y;
            
            const denom = (x1 - x3) * (y2 - y3) - (x2 - x3) * (y1 - y3);
            
            const a = ((u1 - u3) * (y2 - y3) - (u2 - u3) * (y1 - y3)) / denom;
            const b = ((x1 - x3) * (u2 - u3) - (x2 - x3) * (u1 - u3)) / denom;
            const c = ((v1 - v3) * (y2 - y3) - (v2 - v3) * (y1 - y3)) / denom;
            const d = ((x1 - x3) * (v2 - v3) - (x2 - x3) * (v1 - v3)) / denom;
            
            const e = u3 - a * x3 - b * y3;
            const f = v3 - c * x3 - d * y3;
            
            manualAlignmentTransform = { a, b, c, d, e, f };
            
            console.log('Manual alignment transform calculated:', manualAlignmentTransform);
        }
        
        async function applyManualAlignmentAndRender() {
            clearManualAlignmentPoints();
            hideManualAlignmentStatus();
            
            // Switch to toggle mode to show the aligned result
            currentMode = 'toggle';
            viewMode = 'auto';
            
            // Start auto-toggle to show both maps
            if (!autoToggleInterval) {
                toggleAutoMode();
            }
            
            await renderCurrentPage();
            
            showManualAlignmentStatus('Dopasowanie ukończone! Mapy migają na przemian.');
            setTimeout(() => {
                hideManualAlignmentStatus();
            }, 3000);
        }
    </script>
</body>
</html>
